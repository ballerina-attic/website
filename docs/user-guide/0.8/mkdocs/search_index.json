{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Ballerina!\n\n\nBallerina is the premier programming language designed for integration. It allows you to connect apps and services to handle all types of integration scenarios, such as collecting top tweets from a specific location and adding them to a Google spreadsheet, generating emails with real-time quotes pulled from a stock quote service, transforming and routing data based on advanced logic, and much more. \n\n\nFlexible\n\n\nYou can build your integrations from sequence diagrams, or write code in the Ballerina language or Swagger. You can also use plug-ins to write Ballerina code in IntelliJ IDEA, Vim, and more. Ballerina is open source, so you can see exactly how it works and join the growing community of users contributing to its code base. And its API allows you to leverage its functionality from other programs.\n\n\nPowerful\n\n\nThe Ballerina language was designed from the ground up specifically for integration and can handle everything from a simple Hello World program to complex service chaining and content-based routing scenarios. It comes with native support for REST, Swagger, JSON, and XML, and it includes connectors for popular services like Twitter and Facebook. The runtime is lightweight and incredibly fast, and you can run it alone without the development tools in a production environment.  \n\n\nBeautiful\n\n\nThe Ballerina Composer allows you to easily draw your integration scenario and all the components that need to interact by dragging and dropping elements onto a canvas. As you create the diagram, the integration code is written for you, and at any time you can switch to the Source view to see and modify the code. The Ballerina language syntax was modeled after the best practices of popular languages, so it's intuitive and easy to work with.   \n\n\nLet's go!\n\n\nTo get started, go to the \nQuick Tour\n and take Ballerina for a spin!",
            "title": "Welcome"
        },
        {
            "location": "/#welcome-to-ballerina",
            "text": "Ballerina is the premier programming language designed for integration. It allows you to connect apps and services to handle all types of integration scenarios, such as collecting top tweets from a specific location and adding them to a Google spreadsheet, generating emails with real-time quotes pulled from a stock quote service, transforming and routing data based on advanced logic, and much more.",
            "title": "Welcome to Ballerina!"
        },
        {
            "location": "/#flexible",
            "text": "You can build your integrations from sequence diagrams, or write code in the Ballerina language or Swagger. You can also use plug-ins to write Ballerina code in IntelliJ IDEA, Vim, and more. Ballerina is open source, so you can see exactly how it works and join the growing community of users contributing to its code base. And its API allows you to leverage its functionality from other programs.",
            "title": "Flexible"
        },
        {
            "location": "/#powerful",
            "text": "The Ballerina language was designed from the ground up specifically for integration and can handle everything from a simple Hello World program to complex service chaining and content-based routing scenarios. It comes with native support for REST, Swagger, JSON, and XML, and it includes connectors for popular services like Twitter and Facebook. The runtime is lightweight and incredibly fast, and you can run it alone without the development tools in a production environment.",
            "title": "Powerful"
        },
        {
            "location": "/#beautiful",
            "text": "The Ballerina Composer allows you to easily draw your integration scenario and all the components that need to interact by dragging and dropping elements onto a canvas. As you create the diagram, the integration code is written for you, and at any time you can switch to the Source view to see and modify the code. The Ballerina language syntax was modeled after the best practices of popular languages, so it's intuitive and easy to work with.",
            "title": "Beautiful"
        },
        {
            "location": "/#lets-go",
            "text": "To get started, go to the  Quick Tour  and take Ballerina for a spin!",
            "title": "Let's go!"
        },
        {
            "location": "/quick-tour/",
            "text": "Quick Tour\n\n\nNow that you know \na little bit about Ballerina\n, let's take it for a spin! \n\n\nInstall Ballerina\n\n\n\n\nGo to http://www.ballerinalang.org and click \nDownload\n. \n\n\nDownload the Ballerina Tools distribution and unzip it on your computer. Ballerina Tools includes the Ballerina runtime plus the visual editor (Composer) and other tools. \n\n\nAdd the \n<ballerina_home>/bin\n directory to your $PATH environment variable so that you can run the Ballerina commands from anywhere. \n\n\n\n\n\n\nNOTE: Throughout this documentation, \n<ballerina_home>\n refers to the Ballerina directory you just installed. \n\n\n\n\nRun HelloWorld\n\n\nThe HelloWorld sample will show you how easy it is to run Ballerina, send it a request, and get a response. \n\n\nLet's take a look at what the sample looks like in the Ballerina programming language:\n\n\nimport ballerina.lang.system;\nfunction main (string[] args) {\n  system:println(\"Hello, World!\");\n}\n\n\n\n\nThe HelloWorld sample doesn't take any specific input, so simply running it will cause it to print \"Hello, World!\" at the command line.\n\n\nAt the command prompt, navigate to the \n<ballerina_home>/samples/helloWorld\n directory and enter the following line:\n\n\nballerina run main helloworld.bal\n\n\n\n\nYou will see the following response:\n\n\nHello, World!\n\n\n\n\nYou just started Ballerina, ran the HelloWorld sample, and got a response within seconds. \n\n\nPretty simple and straightforward, right? Now, let's look at something a little more interesting: the Composer.\n\n\nRun the Composer\n\n\n\n\n\n\nAt the command prompt, type \ncomposer\n.\n\n\n\n\n\n\nAccess the Composer from the following URL in your browser: http://localhost:9091\n\n\nThe welcome page of Ballerina Composer appears. \n\n\n\n\nLet's open a sample and take a look around. \n\n\n\n\n\n\nClick \nechoService\n.\n\n\nThe Echo Service program displays in the Composer.\n\n\n\n\n\n\n\n\nNotice that on the left you have a tool palette containing the various constructs that you'll use to build your integration. On the right, you have a visual editor with a canvas onto which you drag those constructs. This is where you build your sequence diagrams that define your integration logic. \n\n\nAlso notice in the lower right corner the \nSource View\n and \nSwagger View\n buttons. \n\n\n\n\n\n\nClick \nSource View\n. \n\n\n\n\nYou'll see the source code editor that represents the sequence diagram as code in the Ballerina language. You can go back and forth between the visual editor and the source code and make your edits in either place. \n\n\n\n\n\n\nClick \nSwagger View\n. \n\n\n\n\nThis editor allows you to write Swagger definitions to create services.\n\n\n\n\n\n\nClick \nDesign View\n to return to the visual editor. \n\n\n\n\n\n\nNow that you've had a look around, it's time to take the leap and \nwrite your first Ballerina program\n.",
            "title": "Quick Tour"
        },
        {
            "location": "/quick-tour/#quick-tour",
            "text": "Now that you know  a little bit about Ballerina , let's take it for a spin!",
            "title": "Quick Tour"
        },
        {
            "location": "/quick-tour/#install-ballerina",
            "text": "Go to http://www.ballerinalang.org and click  Download .   Download the Ballerina Tools distribution and unzip it on your computer. Ballerina Tools includes the Ballerina runtime plus the visual editor (Composer) and other tools.   Add the  <ballerina_home>/bin  directory to your $PATH environment variable so that you can run the Ballerina commands from anywhere.     NOTE: Throughout this documentation,  <ballerina_home>  refers to the Ballerina directory you just installed.",
            "title": "Install Ballerina"
        },
        {
            "location": "/quick-tour/#run-helloworld",
            "text": "The HelloWorld sample will show you how easy it is to run Ballerina, send it a request, and get a response.   Let's take a look at what the sample looks like in the Ballerina programming language:  import ballerina.lang.system;\nfunction main (string[] args) {\n  system:println(\"Hello, World!\");\n}  The HelloWorld sample doesn't take any specific input, so simply running it will cause it to print \"Hello, World!\" at the command line.  At the command prompt, navigate to the  <ballerina_home>/samples/helloWorld  directory and enter the following line:  ballerina run main helloworld.bal  You will see the following response:  Hello, World!  You just started Ballerina, ran the HelloWorld sample, and got a response within seconds.   Pretty simple and straightforward, right? Now, let's look at something a little more interesting: the Composer.",
            "title": "Run HelloWorld"
        },
        {
            "location": "/quick-tour/#run-the-composer",
            "text": "At the command prompt, type  composer .    Access the Composer from the following URL in your browser: http://localhost:9091  The welcome page of Ballerina Composer appears.    Let's open a sample and take a look around.     Click  echoService .  The Echo Service program displays in the Composer.     Notice that on the left you have a tool palette containing the various constructs that you'll use to build your integration. On the right, you have a visual editor with a canvas onto which you drag those constructs. This is where you build your sequence diagrams that define your integration logic.   Also notice in the lower right corner the  Source View  and  Swagger View  buttons.     Click  Source View .    You'll see the source code editor that represents the sequence diagram as code in the Ballerina language. You can go back and forth between the visual editor and the source code and make your edits in either place.     Click  Swagger View .    This editor allows you to write Swagger definitions to create services.    Click  Design View  to return to the visual editor.     Now that you've had a look around, it's time to take the leap and  write your first Ballerina program .",
            "title": "Run the Composer"
        },
        {
            "location": "/tutorials/first-program/",
            "text": "Write your First Program\n\n\nNow that you\u2019ve taken the \nQuick Tour\n, let's dig a little deeper and write your first Ballerina integration program. This tutorial will teach you how to run Ballerina in standalone and server mode, use the editor to build your integration, understand the key concepts, and get familiar with the Ballerina language.\n\n\nRunning Ballerina\n\n\nIn the \nQuick Tour\n, you learned how to start Ballerina and run a sample program from the \n<ballerina_home>/samples/helloWorld\n directory with a single command:\n\n\nballerina run main helloWorld.bal\n\n\n\n\nAfter the HelloWorld program executed, Ballerina stopped. This approach is called \nstandalone mode\n, and it's useful when you want to execute a program once and then stop as soon as it has finished its job. It runs the \nmain()\n function of the program you specify and then exits. \n\n\nYou can also run Ballerina as a \nserver\n, so that it can deploy one or more services that wait for requests. To see how this works, let's go to your \n<ballerina_home>/samples/helloWorldService\n directory, and then run Ballerina in server mode and deploy the HelloWorldService program:\n\n\nballerina run service helloWorldService.bal\n\n\n\n\nIn this case, Ballerina ran and deployed the HelloWorldService program as a service, which is waiting for a request. Let's send it one now. The Ballerina server is available at \nlocalhost:9090\n, and HelloWorldService is available at context \nhello\n. Open another command line window and use the \ncurl\n client to call the service as follows:\n\n\ncurl -v http://localhost:9090/hello\n\n\n\n\nThe service receives the request and executes its logic, printing \"Hello, World!\" on the command line. Notice that the Ballerina server is still running in the background, waiting for more requests to come in. You can stop the Ballerina server by pressing Ctrl-C. \n\n\nCreating an integration\n\n\nIt's time to create your first integration! In this exercise, we are going to create a service that takes an incoming message, extracts the text, and sends a message back to the client with that same text. \n\n\nAdd a service and resource\n\n\nFirst, we add a \nservice\n construct to the canvas in the Composer. A service is a container for all the other constructs and represents a single unit of functionality that can be accessed remotely.\n\n\n\n\nIf the Composer is not already running, run it as described in the \nQuick Tour\n.\n\n\nOn the tool palette, click the service icon and drag it to the canvas. \n\n\n\n\nA box appears with the name \nnewService\n, and inside it is another box called \nnewResource\n with some content already created for you. \n\n\nA \nresource\n is a single request handler within a service. This is where we will program the logic describing how to handle certain types of requests from incoming messages to this service. \n\n\nBy default, the resource is configured to accept a message \nm\n. You can see this by clicking the Arguments icon in the upper right corner of the resource box: \n\n\n\n\nWhen you click it, you'll see \nmessage m\n listed below the fields. Click the Arguments icon again to close its window.\n\n\nLet's rename both the service and resource. \n\n\n\n\nHighlight the name \nnewService\n and type \nmyEchoService\n in its place. \n\n\nChange \nnewResource\n to \nmyEchoResource\n in the same way. \n\n\n\n\nSet the base path\n\n\nNow, let's set the base path for this service. This will be the context portion of the URL that clients will use to send requests to this service. \n\n\n\n\nIn the upper right corner of the \nservice\n box (not the resource box this time), click the Annotations (@) icon.\n\n\nMake sure \nhttp:BasePath\n is selected in the list, type \n/myecho\n in the text box, and then press Enter or click the + symbol to its right. \n\n\n\n\nThe base path is now set, so that when you deploy this service, clients will be able to send requests to it using the URL http://localhost:9090/myecho.\n\n\nChange GET to POST\n\n\nWhen you added the service, Ballerina configured the resource to use the GET method by default. Because we are going to use the incoming message to post a reply, let's change it to POST. \n\n\n\n\nClick the Annotations (@) icon in the upper right corner of the \nresource\n box (not the service box).\n\n\nClick \nhttp:GET\n, highlight \nGET\n, and type \nPOST\n. \n\n\nClick the Annotations icon again to hide the box. \n\n\n\n\nYou can click the symbol again to confirm that GET was in fact changed to POST. You can also click the \nSource View\n button in the lower right corner to see the changes that are being made to the Ballerina code as you work with the visual editor.\n\n\nAdd a function\n\n\nNow, let's add a function that will take the incoming message and convert it to a response that gets sent back to the client. Because we are sending the original request back instead of composing a new message to send to the client, we need to strip its original headers before we reply, as those headers are intended for use in the client -> server direction and not the other way around. The \nballerina.net.http\n package includes a native function called \nconvertToResponse\n that removes the incoming HTTP headers when replying to the client. Let's add that function to our flow.\n\n\n\n\nOn the tool palette, scroll down to the \nballerina.net.http\n section, click the \nconvertToResponse\n function, and drag it to the canvas below \nStart\n. \n\n\nHighlight \nmessage\n in \nhttp:convertToResponse(message)\n and replace it with \nm\n, which is the incoming message, so that it looks like this: \nhttp:convertToResponse(m)\n\n\n\n\nAdd the reply\n\n\nNow that we've added the function that will convert the incoming message text to a response, we just need to instruct the program to send the response back to the client. We will use the Reply icon in the tool palette, which looks like this:\n\n\n\n\n\n\n\n\nOn the tool palette, click the Reply icon and drag it to the canvas under the \nconvertToResponse\n function you just added. \n\n\nIt appears as a box with an arrow pointing back to the client. \n\n\n\n\n\n\nClick the reply box you just added and type \nm\n to instruct the program to send the message processed by the \nconvertToResponse\n function back to the client. Click outside of the box. \n\n\n\n\n\n\nThis completes the sequence, so you are now ready to save and run your integration program.\n\n\nSave the program\n\n\n\n\nClick the \nFile\n menu and choose \nSave As\n. \n\n\nSave it as \nmyEcho.bal\n in your Ballerina \nsamples\n directory. \n\n\n\n\nRun the program\n\n\nYou can run a Ballerina program from inside the Composer using the Run icon, which is to the left of the tool palette:\n\n\n\n\nClick the Run icon now and click \nService\n. \n\n\nIf you were creating a Ballerina program with a \nmain()\n function, you would click \nApplication\n instead.\n\n\nYour service is now deployed and running on the Ballerina server. \n\n\nSend the request\n\n\nIn a new command prompt, use curl to send a request to your program:\n\n\ncurl -v http://localhost:9090/myecho -d \"Hello World......\"\n\n\n\n\nThe service receives the request, takes the text \nHello World......\n from the incoming message, converts it into a response without the client headers, and sends it back to the command line where the request was sent.\n\n\nYou have now completed your first Ballerina program! If you run into problems, you can troubleshoot by comparing your code with the Echo sample.  \n\n\nNext steps\n\n\nNow that you're familiar with running Ballerina in standalone and server mode, using the Composer to build an integration program, and creating a service and resource, you are ready to learn more. \n\n\n\n\nRead the \nKey Concepts\n page to familiarize yourself with the rest of the main features you need to know about.\n\n\nBrowse through the \nSamples\n and use them as templates for your own programs.\n\n\nSee the \nLanguage Reference\n for complete information on using the Ballerina language.",
            "title": "Write your First Program"
        },
        {
            "location": "/tutorials/first-program/#write-your-first-program",
            "text": "Now that you\u2019ve taken the  Quick Tour , let's dig a little deeper and write your first Ballerina integration program. This tutorial will teach you how to run Ballerina in standalone and server mode, use the editor to build your integration, understand the key concepts, and get familiar with the Ballerina language.",
            "title": "Write your First Program"
        },
        {
            "location": "/tutorials/first-program/#running-ballerina",
            "text": "In the  Quick Tour , you learned how to start Ballerina and run a sample program from the  <ballerina_home>/samples/helloWorld  directory with a single command:  ballerina run main helloWorld.bal  After the HelloWorld program executed, Ballerina stopped. This approach is called  standalone mode , and it's useful when you want to execute a program once and then stop as soon as it has finished its job. It runs the  main()  function of the program you specify and then exits.   You can also run Ballerina as a  server , so that it can deploy one or more services that wait for requests. To see how this works, let's go to your  <ballerina_home>/samples/helloWorldService  directory, and then run Ballerina in server mode and deploy the HelloWorldService program:  ballerina run service helloWorldService.bal  In this case, Ballerina ran and deployed the HelloWorldService program as a service, which is waiting for a request. Let's send it one now. The Ballerina server is available at  localhost:9090 , and HelloWorldService is available at context  hello . Open another command line window and use the  curl  client to call the service as follows:  curl -v http://localhost:9090/hello  The service receives the request and executes its logic, printing \"Hello, World!\" on the command line. Notice that the Ballerina server is still running in the background, waiting for more requests to come in. You can stop the Ballerina server by pressing Ctrl-C.",
            "title": "Running Ballerina"
        },
        {
            "location": "/tutorials/first-program/#creating-an-integration",
            "text": "It's time to create your first integration! In this exercise, we are going to create a service that takes an incoming message, extracts the text, and sends a message back to the client with that same text.",
            "title": "Creating an integration"
        },
        {
            "location": "/tutorials/first-program/#add-a-service-and-resource",
            "text": "First, we add a  service  construct to the canvas in the Composer. A service is a container for all the other constructs and represents a single unit of functionality that can be accessed remotely.   If the Composer is not already running, run it as described in the  Quick Tour .  On the tool palette, click the service icon and drag it to the canvas.    A box appears with the name  newService , and inside it is another box called  newResource  with some content already created for you.   A  resource  is a single request handler within a service. This is where we will program the logic describing how to handle certain types of requests from incoming messages to this service.   By default, the resource is configured to accept a message  m . You can see this by clicking the Arguments icon in the upper right corner of the resource box:    When you click it, you'll see  message m  listed below the fields. Click the Arguments icon again to close its window.  Let's rename both the service and resource.    Highlight the name  newService  and type  myEchoService  in its place.   Change  newResource  to  myEchoResource  in the same way.",
            "title": "Add a service and resource"
        },
        {
            "location": "/tutorials/first-program/#set-the-base-path",
            "text": "Now, let's set the base path for this service. This will be the context portion of the URL that clients will use to send requests to this service.    In the upper right corner of the  service  box (not the resource box this time), click the Annotations (@) icon.  Make sure  http:BasePath  is selected in the list, type  /myecho  in the text box, and then press Enter or click the + symbol to its right.    The base path is now set, so that when you deploy this service, clients will be able to send requests to it using the URL http://localhost:9090/myecho.",
            "title": "Set the base path"
        },
        {
            "location": "/tutorials/first-program/#change-get-to-post",
            "text": "When you added the service, Ballerina configured the resource to use the GET method by default. Because we are going to use the incoming message to post a reply, let's change it to POST.    Click the Annotations (@) icon in the upper right corner of the  resource  box (not the service box).  Click  http:GET , highlight  GET , and type  POST .   Click the Annotations icon again to hide the box.    You can click the symbol again to confirm that GET was in fact changed to POST. You can also click the  Source View  button in the lower right corner to see the changes that are being made to the Ballerina code as you work with the visual editor.",
            "title": "Change GET to POST"
        },
        {
            "location": "/tutorials/first-program/#add-a-function",
            "text": "Now, let's add a function that will take the incoming message and convert it to a response that gets sent back to the client. Because we are sending the original request back instead of composing a new message to send to the client, we need to strip its original headers before we reply, as those headers are intended for use in the client -> server direction and not the other way around. The  ballerina.net.http  package includes a native function called  convertToResponse  that removes the incoming HTTP headers when replying to the client. Let's add that function to our flow.   On the tool palette, scroll down to the  ballerina.net.http  section, click the  convertToResponse  function, and drag it to the canvas below  Start .   Highlight  message  in  http:convertToResponse(message)  and replace it with  m , which is the incoming message, so that it looks like this:  http:convertToResponse(m)",
            "title": "Add a function"
        },
        {
            "location": "/tutorials/first-program/#add-the-reply",
            "text": "Now that we've added the function that will convert the incoming message text to a response, we just need to instruct the program to send the response back to the client. We will use the Reply icon in the tool palette, which looks like this:     On the tool palette, click the Reply icon and drag it to the canvas under the  convertToResponse  function you just added.   It appears as a box with an arrow pointing back to the client.     Click the reply box you just added and type  m  to instruct the program to send the message processed by the  convertToResponse  function back to the client. Click outside of the box.     This completes the sequence, so you are now ready to save and run your integration program.",
            "title": "Add the reply"
        },
        {
            "location": "/tutorials/first-program/#save-the-program",
            "text": "Click the  File  menu and choose  Save As .   Save it as  myEcho.bal  in your Ballerina  samples  directory.",
            "title": "Save the program"
        },
        {
            "location": "/tutorials/first-program/#run-the-program",
            "text": "You can run a Ballerina program from inside the Composer using the Run icon, which is to the left of the tool palette:   Click the Run icon now and click  Service .   If you were creating a Ballerina program with a  main()  function, you would click  Application  instead.  Your service is now deployed and running on the Ballerina server.",
            "title": "Run the program"
        },
        {
            "location": "/tutorials/first-program/#send-the-request",
            "text": "In a new command prompt, use curl to send a request to your program:  curl -v http://localhost:9090/myecho -d \"Hello World......\"  The service receives the request, takes the text  Hello World......  from the incoming message, converts it into a response without the client headers, and sends it back to the command line where the request was sent.  You have now completed your first Ballerina program! If you run into problems, you can troubleshoot by comparing your code with the Echo sample.",
            "title": "Send the request"
        },
        {
            "location": "/tutorials/first-program/#next-steps",
            "text": "Now that you're familiar with running Ballerina in standalone and server mode, using the Composer to build an integration program, and creating a service and resource, you are ready to learn more.    Read the  Key Concepts  page to familiarize yourself with the rest of the main features you need to know about.  Browse through the  Samples  and use them as templates for your own programs.  See the  Language Reference  for complete information on using the Ballerina language.",
            "title": "Next steps"
        },
        {
            "location": "/key-concepts/",
            "text": "Key Concepts\n\n\nEach Ballerina program represents a discrete unit of functionality that performs an integration task. You can create a Ballerina program as a \nservice\n that runs in the Ballerina server and awaits requests over HTTP. Or you can create your program as an executable program that executes a \nmain()\n function and then exits. Your Ballerina programs can be as simple or as complex as you like, but for best results, each program should focus on a specific task.\n\n\nAs you create your program, there are several constructs available that you can use:\n\n\n\n\nService\n: When defining a Ballerina program as a service instead of an executable program, the \nservice\n construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that you use when sending requests to the service.\n\n\nResource\n: A resource is a single request handler within a service. When you create a service in Ballerina using the visual editor, a default resource is automatically created as well. The resource contains the integration logic.  \n\n\n\n\nFunction\n: A function is a single operation. Ballerina includes a set of native functions you can call, such as the \nConvertToResponse()\n function you used in the \nWrite your First Program\n tutorial, and you can define additional functions within your Ballerina programs. \n\n\nThe \nmain()\n function contains the core integration logic when creating an executable program instead of a service. When you run the program, the \nmain()\n function executes, and then the program terminates. You can define additional functions, connectors, etc. inside the program and call them from \nmain()\n. For a more complex example of an executable Ballerina program, see the Twitter Connector sample.  \n\n\n\n\n\n\nWorker\n: A worker is a thread that executes a function.  \n\n\n\n\nConnector\n: A connector represents a participant in the integration and is used to interact with an external system or a service you've defined in Ballerina. Ballerina includes a set of standard connectors that allow you to connect to Twitter, Facebook, and more, and you can define additional connectors within your Ballerina programs.  \n\n\nAction\n: An action is an operation you can execute against a connector. It represents a single interaction with a participant of the integration.  \n\n\n\n\nYou can also define constants, variables, structured types, and more as you do with other programming languages, and you can use logic statements like if and while. For more information, see the \nLanguage Reference\n.",
            "title": "Key Concepts"
        },
        {
            "location": "/key-concepts/#key-concepts",
            "text": "Each Ballerina program represents a discrete unit of functionality that performs an integration task. You can create a Ballerina program as a  service  that runs in the Ballerina server and awaits requests over HTTP. Or you can create your program as an executable program that executes a  main()  function and then exits. Your Ballerina programs can be as simple or as complex as you like, but for best results, each program should focus on a specific task.  As you create your program, there are several constructs available that you can use:   Service : When defining a Ballerina program as a service instead of an executable program, the  service  construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that you use when sending requests to the service.  Resource : A resource is a single request handler within a service. When you create a service in Ballerina using the visual editor, a default resource is automatically created as well. The resource contains the integration logic.     Function : A function is a single operation. Ballerina includes a set of native functions you can call, such as the  ConvertToResponse()  function you used in the  Write your First Program  tutorial, and you can define additional functions within your Ballerina programs.   The  main()  function contains the core integration logic when creating an executable program instead of a service. When you run the program, the  main()  function executes, and then the program terminates. You can define additional functions, connectors, etc. inside the program and call them from  main() . For a more complex example of an executable Ballerina program, see the Twitter Connector sample.      Worker : A worker is a thread that executes a function.     Connector : A connector represents a participant in the integration and is used to interact with an external system or a service you've defined in Ballerina. Ballerina includes a set of standard connectors that allow you to connect to Twitter, Facebook, and more, and you can define additional connectors within your Ballerina programs.    Action : An action is an operation you can execute against a connector. It represents a single interaction with a participant of the integration.     You can also define constants, variables, structured types, and more as you do with other programming languages, and you can use logic statements like if and while. For more information, see the  Language Reference .",
            "title": "Key Concepts"
        },
        {
            "location": "/tools/",
            "text": "Tools\n\n\nBallerina provides several tools to help you create, document, and test your code.\n\n\nFlexible composer\n\n\nThe Ballerina Composer provides three ways to create your integrations:\n\n\n\n\nDraw sequence diagrams in the Design view\n\n\nWrite Ballerina code in the Source view\n\n\nCreate services by writing \nSwagger\n definitions in the Swagger view\n\n\n\n\nAs you work in one view, the diagrams and code are updated in the other views, allowing you to switch between them seamlessly as needed. Note that the Swagger view is only for defining services, so if you are creating an executable program with a \nmain()\n function instead of a service, you cannot use the Swagger view. \n\n\nIDE plug-ins\n\n\nYou can use plug-ins to write Ballerina code in your favorite IDE. The following plug-ins are available in Github:\n\n\n\n\nAtom\n\n\nIntelliJ IDEA\n\n\nSublime Text 3\n\n\nVim\n\n\nVisual Studio Code (VS Code)\n\n\n\n\nSwagger to Ballerina code generator\n\n\nYou can use existing Swagger files to generate connectors and services in Ballerina code. For details, see the \nSwagger to Ballerina Code Generator\n.\n\n\nAPI documentation generator\n\n\nAs you develop new connectors, actions, and functions that you want to share with others, it's important to add API documentation that describes each entity and how it's used. Ballerina provides a framework called \nDocerina\n that generates API documentation from your annotations in your Ballerina files. You can check it out at https://github.com/ballerinalang/docerina. \n\n\nTest framework\n\n\nWhen you write your code in Ballerina Composer, the syntax is checked for you as you write it, and you can use the Debug button to step through your program. You can also manually test a Ballerina file using the following command:\n\n\nballerina test <ballerina_file>\n\n\n\n\nBallerina provides a testing framework called \nTesterina\n that you can use for your programs. You can check it out at https://github.com/ballerinalang/testerina.",
            "title": "Tools"
        },
        {
            "location": "/tools/#tools",
            "text": "Ballerina provides several tools to help you create, document, and test your code.",
            "title": "Tools"
        },
        {
            "location": "/tools/#flexible-composer",
            "text": "The Ballerina Composer provides three ways to create your integrations:   Draw sequence diagrams in the Design view  Write Ballerina code in the Source view  Create services by writing  Swagger  definitions in the Swagger view   As you work in one view, the diagrams and code are updated in the other views, allowing you to switch between them seamlessly as needed. Note that the Swagger view is only for defining services, so if you are creating an executable program with a  main()  function instead of a service, you cannot use the Swagger view.",
            "title": "Flexible composer"
        },
        {
            "location": "/tools/#ide-plug-ins",
            "text": "You can use plug-ins to write Ballerina code in your favorite IDE. The following plug-ins are available in Github:   Atom  IntelliJ IDEA  Sublime Text 3  Vim  Visual Studio Code (VS Code)",
            "title": "IDE plug-ins"
        },
        {
            "location": "/tools/#swagger-to-ballerina-code-generator",
            "text": "You can use existing Swagger files to generate connectors and services in Ballerina code. For details, see the  Swagger to Ballerina Code Generator .",
            "title": "Swagger to Ballerina code generator"
        },
        {
            "location": "/tools/#api-documentation-generator",
            "text": "As you develop new connectors, actions, and functions that you want to share with others, it's important to add API documentation that describes each entity and how it's used. Ballerina provides a framework called  Docerina  that generates API documentation from your annotations in your Ballerina files. You can check it out at https://github.com/ballerinalang/docerina.",
            "title": "API documentation generator"
        },
        {
            "location": "/tools/#test-framework",
            "text": "When you write your code in Ballerina Composer, the syntax is checked for you as you write it, and you can use the Debug button to step through your program. You can also manually test a Ballerina file using the following command:  ballerina test <ballerina_file>  Ballerina provides a testing framework called  Testerina  that you can use for your programs. You can check it out at https://github.com/ballerinalang/testerina.",
            "title": "Test framework"
        },
        {
            "location": "/samples/",
            "text": "Samples\n\n\nThe best way to start writing your Ballerina program is to use the samples as templates. Each sample includes a walk-through of the code so you can see how it's done. \n\n\n\n\nhelloWorld\n: A simple executable program that prints \"Hello World\" to the command line.\n\n\nhelloWorldService\n: A service that prints \"Hello World\" to the command line.\n\n\nechoService\n: A service that takes text from the incoming request message and sends it back to the client as a response.\n\n\npassThroughService\n: A service that sends the incoming request message to a backend service and sends a response back to the client.\n\n\nrestfulService\n: A RESTful ecommerce service that defines three resources and illustrates how you can build the business logic for each resource.\n\n\nroutingServices\n: Contains two separate services that route messages to different backends based on the message content or header value.\n\n\nserviceChaining\n: Contains a composite service, ATMLocatorService, which illustrates how to chain services together to get the required information. It calls one service to find the nearest ATM by ZIP code, it calls a second service to get the address of that ATM, and then it composes the response and sends the information back to the client. \n\n\ntwitterConnector\n: An executable program that defines a connector that you can use to connect to a Twitter account and post a status update (tweet).\n\n\ntweetOpenPR\n: An executable program that uses the GitHub API to get the open pull requests for a specific repository and then tweets the total number of pull requests on Twitter.\n\n\ntweetMediumFeed\n: An executable program that retrieves the feed for WSO2 from Medium.com and tweets the first item's title.",
            "title": "Samples"
        },
        {
            "location": "/samples/#samples",
            "text": "The best way to start writing your Ballerina program is to use the samples as templates. Each sample includes a walk-through of the code so you can see how it's done.    helloWorld : A simple executable program that prints \"Hello World\" to the command line.  helloWorldService : A service that prints \"Hello World\" to the command line.  echoService : A service that takes text from the incoming request message and sends it back to the client as a response.  passThroughService : A service that sends the incoming request message to a backend service and sends a response back to the client.  restfulService : A RESTful ecommerce service that defines three resources and illustrates how you can build the business logic for each resource.  routingServices : Contains two separate services that route messages to different backends based on the message content or header value.  serviceChaining : Contains a composite service, ATMLocatorService, which illustrates how to chain services together to get the required information. It calls one service to find the nearest ATM by ZIP code, it calls a second service to get the address of that ATM, and then it composes the response and sends the information back to the client.   twitterConnector : An executable program that defines a connector that you can use to connect to a Twitter account and post a status update (tweet).  tweetOpenPR : An executable program that uses the GitHub API to get the open pull requests for a specific repository and then tweets the total number of pull requests on Twitter.  tweetMediumFeed : An executable program that retrieves the feed for WSO2 from Medium.com and tweets the first item's title.",
            "title": "Samples"
        },
        {
            "location": "/lang-ref/lang-overview/",
            "text": "Overview\n\n\nThis page provides an overview of the Ballerina language and the main points you need to know about creating a Ballerina program. Be sure to read \nKey Concepts\n to familiarize yourself with Ballerina entities such as services.\n\n\nStructure of a Ballerina program\n\n\nA Ballerina file is structured as follows:\n\n\n[package PackageName;]\n[import PackageName [version ImportVersionNumber] [as Identifier];]*\n\n(ServiceDefinition |\n FunctionDefinition |\n ConnectorDefinition |\n TypeDefinition |\n TypeMapperDefinition |\n ConstantDefinition)+\n\n\n\n\nNote: Terminals of the language (keywords) are lowercase, whereas non-terminals are uppercase.\n\n\nEach of the Ballerina entities such as services and connectors are described in detail in their own pages in this guide.\n\n\nA Ballerina program can consist of a number of Ballerina files, which may be in one or more packages. Ballerina uses a modular approach for managing names and organizing code into files. In summary, Ballerina entities (functions, services, etc.) all have globally unique qualified names consisting of their package name and the entity name. For complete information, see \nPackaging and Running Programs\n.\n\n\nDevelopment tools\n\n\nBallerina provides several tools to help you create, document, and test your code. For more information, see \nTools\n.\n\n\nExpressions\n\n\nSimilar to languages such as Java, Go, etc, Ballerina supports the following expressions: \n\n\n\n\nMathematical expressions \n(x + y, x/y, etc.)\n\n\nFunction calls \n(foo(a,b))\n\n\nAction calls \n(tweet(twitterActor, \"hello\"))\n\n\nComplex expressions \n(foo(a,bar(c,d)))\n\n\n\n\nReserved names\n\n\nWhen naming your Ballerina elements (services, resources, actions, etc.), Swagger files, program files, and packages, do not use the following terms for the name, as these terms are reserved in Ballerina:\n\n\n\n\naction\n\n\nall\n\n\nany\n\n\nas\n\n\nboolean\n\n\nbreak\n\n\ncatch\n\n\nconnector\n\n\nconst\n\n\ndatatable\n\n\ndouble\n\n\nelse\n\n\nexception\n\n\nfalse\n\n\nfork\n\n\nfunction\n\n\nif\n\n\nimport\n\n\nint \n\n\njson\n\n\nmap\n\n\nmessage\n\n\nnative\n\n\nnull\n\n\npackage\n\n\nreply\n\n\nresource\n\n\nreturn\n\n\nservice\n\n\nstring\n\n\nstruct\n\n\nthrows\n\n\ntimeout\n\n\ntrue\n\n\ntry\n\n\ntypemapper\n\n\nwhile\n\n\nworker\n\n\nxml\n\n\nxmldocument",
            "title": "Overview"
        },
        {
            "location": "/lang-ref/lang-overview/#overview",
            "text": "This page provides an overview of the Ballerina language and the main points you need to know about creating a Ballerina program. Be sure to read  Key Concepts  to familiarize yourself with Ballerina entities such as services.",
            "title": "Overview"
        },
        {
            "location": "/lang-ref/lang-overview/#structure-of-a-ballerina-program",
            "text": "A Ballerina file is structured as follows:  [package PackageName;]\n[import PackageName [version ImportVersionNumber] [as Identifier];]*\n\n(ServiceDefinition |\n FunctionDefinition |\n ConnectorDefinition |\n TypeDefinition |\n TypeMapperDefinition |\n ConstantDefinition)+  Note: Terminals of the language (keywords) are lowercase, whereas non-terminals are uppercase.  Each of the Ballerina entities such as services and connectors are described in detail in their own pages in this guide.  A Ballerina program can consist of a number of Ballerina files, which may be in one or more packages. Ballerina uses a modular approach for managing names and organizing code into files. In summary, Ballerina entities (functions, services, etc.) all have globally unique qualified names consisting of their package name and the entity name. For complete information, see  Packaging and Running Programs .",
            "title": "Structure of a Ballerina program"
        },
        {
            "location": "/lang-ref/lang-overview/#development-tools",
            "text": "Ballerina provides several tools to help you create, document, and test your code. For more information, see  Tools .",
            "title": "Development tools"
        },
        {
            "location": "/lang-ref/lang-overview/#expressions",
            "text": "Similar to languages such as Java, Go, etc, Ballerina supports the following expressions:    Mathematical expressions  (x + y, x/y, etc.)  Function calls  (foo(a,b))  Action calls  (tweet(twitterActor, \"hello\"))  Complex expressions  (foo(a,bar(c,d)))",
            "title": "Expressions"
        },
        {
            "location": "/lang-ref/lang-overview/#reserved-names",
            "text": "When naming your Ballerina elements (services, resources, actions, etc.), Swagger files, program files, and packages, do not use the following terms for the name, as these terms are reserved in Ballerina:   action  all  any  as  boolean  break  catch  connector  const  datatable  double  else  exception  false  fork  function  if  import  int   json  map  message  native  null  package  reply  resource  return  service  string  struct  throws  timeout  true  try  typemapper  while  worker  xml  xmldocument",
            "title": "Reserved names"
        },
        {
            "location": "/lang-ref/packaging/",
            "text": "Packaging and Running Programs\n\n\nA Ballerina program can consist of a number of Ballerina files, which you can organize into packages simply by creating subdirectories as follows:\n\n\nprogram-name/\n  package-directory-1/\n  package-directory-2/\n  ...\n\n\n\n\nEach Ballerina entity (function, service, etc.) has a globally unique qualified name consisting of its package name and entity name (the file name is NOT part of the entity's name) concatenated with periods. For example, let's say you have a service named StockQuoteService inside a file named \nfoo.bal\n, which is located in the following directory structure:\n\n\nmyProgram\n  resources\n  services\n    foo.bal\n\n\n\n\nThe StockQuoteService entity's fully qualified name would be: \nmyProgram.services.StockQuoteService\n \n\n\nWhen you create a Ballerina program in the Composer, you can declare the program's package in the Package box in the upper left corner of the canvas. Or you can simply type \npackage <package-name>;\n in the Source view. When you declare a package in the program file, be sure to save the file in the correct directory hierarchy to match that package. If a package is not specified, the program will be in the default (unnamed) package. \n\n\nNote:\n When you name your files, directories, and packages, and when you name your Ballerina elements such as services and resources, be sure to avoid using the \nreserved names\n.\n\n\nThe \n<program-name>\n directory contains all the code that the developer writes and may have files in multiple packages (and therefore multiple directories) as in the example above. However, third-party dependencies (which are used via import statements as described below) are discovered from a \nrepository\n and are not physically located within the program source hierarchy. \n\n\nEach Ballerina program can have at most one \nmain()\n function, which serves as the entry point for command-line execution, and zero or more services that are exposed as network entry points when the program is run as a service. Therefore, when organizing your files under a \n<program-name>\n directory, be sure that there is no more than one file containing the \nmain()\n function. \n\n\nImporting packages\n\n\nTo import a package into your program, you can use the Imports box in the upper left corner of the canvas, or simply type \nimport <package-name>;\n in the Source view. \n\n\nAll built-in Ballerina library functions and connectors are defined in the \nballerina.*\n packages. You don\u2019t need to add import statements for system packages that start with \nballerina.lang.*\n because they are imported by default and can be accessed by qualifying the symbol with the last part of the package name. For example, all message data type related functions (which live in the \nballerina.lang.message\n package) can be accessed as \nmessage:FunctionName\n. \n\n\nBallerina libraries\n\n\nCollections of Ballerina code can be packaged as a library so that the resulting package can be shared. Such a library can contain code coming from one or more Ballerina packages.\n\n\nA Ballerina library is organized similar to a program:\n\n\nlibrary-name/\n  package-directory-1/\n  package-directory-2/\n  ...\n\n\n\n\nTo install a library into your repository, you add it as follows:\n\n\nballerina repository add [library-archive-name]\n\n\n\n\nIf the library archive name is not specified, the current directory is assumed to be a library source directory and is inserted into the repository. Library archives have the file extension \n.blz\n.\n\n\nNote\n: In the current release, you can use existing libraries, but you cannot yet build your own library archives.\n\n\nThe Ballerina repository\n\n\nThe Ballerina repository is a collection of Ballerina libraries. \n\n\nThe Ballerina language distribution ships with a built-in repository containing all the core language libraries (containing the \nballerina.*\n packages) as well as third-party libraries. In addition to the default repository, every developer can have a private repository. The default location of the private repository is \n~/.ballerina\n, but you can change the location by setting the BALLERINA_REPOSITORY environment variable.\n\n\nA repository is organized as follows:\n\n\nrepository-directory/\n  src/\n    dir1/\n      version/\n        .bal files in package dir1 of the indicated version\n      dir2/\n        version/ # one version\n          .bal files in package dir1.dir2 of the indicated version\n        version/ # another version\n          .bal files in package dir1.dir2 of the indicated version\n      dir3/\n        version/\n          .bal files in ...\n    dir4/\n    dir5/\n      version/\n        .bal files in ...\n\n\n\n\nCreating Ballerina archives\n\n\nWhile Ballerina programs can be executed directly from the program directory, if you want to create a self-contained package containing all the program code and third-party dependencies, you need to build the program into a packaged format. When a program is packaged using the \nballerina build\n command, the resulting archive will contain not just the Ballerina files that contain the main function and/or services, but also all the Ballerina packages that are imported by all the code needed to execute the main function and/or services. \n\n\nA Ballerina executable archive containing a \nmain()\n function is named with the extension \u201c.bmz\u201d. Use the following command to build an executable archive:\n\n\nballerina build main <main-package-name> [-o filename] \n\n\n\n\nA Ballerina service archive containing one or more services is named with the extension \u201c.bsz\u201d. Use the following command to build a service archive:\n\n\nballerina build service <pkg1> [<pkg2> <pkg3> ...] [-o filename]\n\n\n\n\nNote:\n Package names should be delineated with slashes, such as \norg/foo/bar\n instead of \norg.foo.bar\n. If you do not specify a name for the archive file using the \n-o\n flag, the archive will be named after the last part of the package name.  \n\n\nRunning a Ballerina program\n\n\nThe \nballerina\n command runs a Ballerina program/service in its packaged or unpackaged format.\n\n\nTo execute \nmain()\n from a \n.bal\n file or a package or archive file:\n\n\nballerina run main (filename | packagename | mainarchive)\n\n\n\n\nTo run named services:\n\n\nballerina run service (filename | packagename | servicearchive)+ \n\n\n\n\nTo run a collection of service archives from service root:\n\n\nballerina run service [-sr serviceroot]\n\n\n\n\nCreating and running a Docker image of the archive\n\n\nAfter you have built an archive, you can create a Docker image of it and run it in the container. \n\n\nTo create a Docker image from a Ballerina package, you run \nballerina docker\n and provide the package name as an argument:\n\n\nballerina docker helloWorld.bmz\nballerina: build docker image [helloworld:latest] in docker host [localhost]? (y/n): y\n\nballerina: docker image helloworld:latest successfully built.\n\nUse the following command to start a container.\n        docker run --name determined_aluminum -it helloworld:latest\n\n\n\n\n\nYou can additionally provide a customized image name:\n\n\nballerina docker helloWorld.bmz -t myhelloworld:0.1\nballerina: build docker image [myhelloworld:0.1] in docker host [localhost]? (y/n): y\n\nballerina: docker image myhelloworld:0.1 successfully built.\n\nUse the following command to start a container.\n        docker run --name burning_aids -it myhelloworld:0.1\n\n\n\n\n\nIf you want to use a remote Docker daemon, you can specify it using the -H flag so the Docker image is created at the remote end:\n\n\nballerina docker helloWorld.bmz -H http://127.0.0.1:2375\nballerina: build docker image [myhelloworld:0.1] in docker host [http://127.0.0.1:2375]? (y/n): y\n\nballerina: docker image helloworld:latest successfully built.\n\nUse the following command to start a container.\n        docker run --name future_aquarium -it helloworld:latest\n\n\n\n\nFor more information on the usage of this command, type \nballerina docker --help\n.",
            "title": "Packaging and Running Programs"
        },
        {
            "location": "/lang-ref/packaging/#packaging-and-running-programs",
            "text": "A Ballerina program can consist of a number of Ballerina files, which you can organize into packages simply by creating subdirectories as follows:  program-name/\n  package-directory-1/\n  package-directory-2/\n  ...  Each Ballerina entity (function, service, etc.) has a globally unique qualified name consisting of its package name and entity name (the file name is NOT part of the entity's name) concatenated with periods. For example, let's say you have a service named StockQuoteService inside a file named  foo.bal , which is located in the following directory structure:  myProgram\n  resources\n  services\n    foo.bal  The StockQuoteService entity's fully qualified name would be:  myProgram.services.StockQuoteService    When you create a Ballerina program in the Composer, you can declare the program's package in the Package box in the upper left corner of the canvas. Or you can simply type  package <package-name>;  in the Source view. When you declare a package in the program file, be sure to save the file in the correct directory hierarchy to match that package. If a package is not specified, the program will be in the default (unnamed) package.   Note:  When you name your files, directories, and packages, and when you name your Ballerina elements such as services and resources, be sure to avoid using the  reserved names .  The  <program-name>  directory contains all the code that the developer writes and may have files in multiple packages (and therefore multiple directories) as in the example above. However, third-party dependencies (which are used via import statements as described below) are discovered from a  repository  and are not physically located within the program source hierarchy.   Each Ballerina program can have at most one  main()  function, which serves as the entry point for command-line execution, and zero or more services that are exposed as network entry points when the program is run as a service. Therefore, when organizing your files under a  <program-name>  directory, be sure that there is no more than one file containing the  main()  function.",
            "title": "Packaging and Running Programs"
        },
        {
            "location": "/lang-ref/packaging/#importing-packages",
            "text": "To import a package into your program, you can use the Imports box in the upper left corner of the canvas, or simply type  import <package-name>;  in the Source view.   All built-in Ballerina library functions and connectors are defined in the  ballerina.*  packages. You don\u2019t need to add import statements for system packages that start with  ballerina.lang.*  because they are imported by default and can be accessed by qualifying the symbol with the last part of the package name. For example, all message data type related functions (which live in the  ballerina.lang.message  package) can be accessed as  message:FunctionName .",
            "title": "Importing packages"
        },
        {
            "location": "/lang-ref/packaging/#ballerina-libraries",
            "text": "Collections of Ballerina code can be packaged as a library so that the resulting package can be shared. Such a library can contain code coming from one or more Ballerina packages.  A Ballerina library is organized similar to a program:  library-name/\n  package-directory-1/\n  package-directory-2/\n  ...  To install a library into your repository, you add it as follows:  ballerina repository add [library-archive-name]  If the library archive name is not specified, the current directory is assumed to be a library source directory and is inserted into the repository. Library archives have the file extension  .blz .  Note : In the current release, you can use existing libraries, but you cannot yet build your own library archives.",
            "title": "Ballerina libraries"
        },
        {
            "location": "/lang-ref/packaging/#the-ballerina-repository",
            "text": "The Ballerina repository is a collection of Ballerina libraries.   The Ballerina language distribution ships with a built-in repository containing all the core language libraries (containing the  ballerina.*  packages) as well as third-party libraries. In addition to the default repository, every developer can have a private repository. The default location of the private repository is  ~/.ballerina , but you can change the location by setting the BALLERINA_REPOSITORY environment variable.  A repository is organized as follows:  repository-directory/\n  src/\n    dir1/\n      version/\n        .bal files in package dir1 of the indicated version\n      dir2/\n        version/ # one version\n          .bal files in package dir1.dir2 of the indicated version\n        version/ # another version\n          .bal files in package dir1.dir2 of the indicated version\n      dir3/\n        version/\n          .bal files in ...\n    dir4/\n    dir5/\n      version/\n        .bal files in ...",
            "title": "The Ballerina repository"
        },
        {
            "location": "/lang-ref/packaging/#creating-ballerina-archives",
            "text": "While Ballerina programs can be executed directly from the program directory, if you want to create a self-contained package containing all the program code and third-party dependencies, you need to build the program into a packaged format. When a program is packaged using the  ballerina build  command, the resulting archive will contain not just the Ballerina files that contain the main function and/or services, but also all the Ballerina packages that are imported by all the code needed to execute the main function and/or services.   A Ballerina executable archive containing a  main()  function is named with the extension \u201c.bmz\u201d. Use the following command to build an executable archive:  ballerina build main <main-package-name> [-o filename]   A Ballerina service archive containing one or more services is named with the extension \u201c.bsz\u201d. Use the following command to build a service archive:  ballerina build service <pkg1> [<pkg2> <pkg3> ...] [-o filename]  Note:  Package names should be delineated with slashes, such as  org/foo/bar  instead of  org.foo.bar . If you do not specify a name for the archive file using the  -o  flag, the archive will be named after the last part of the package name.",
            "title": "Creating Ballerina archives"
        },
        {
            "location": "/lang-ref/packaging/#running-a-ballerina-program",
            "text": "The  ballerina  command runs a Ballerina program/service in its packaged or unpackaged format.  To execute  main()  from a  .bal  file or a package or archive file:  ballerina run main (filename | packagename | mainarchive)  To run named services:  ballerina run service (filename | packagename | servicearchive)+   To run a collection of service archives from service root:  ballerina run service [-sr serviceroot]",
            "title": "Running a Ballerina program"
        },
        {
            "location": "/lang-ref/packaging/#creating-and-running-a-docker-image-of-the-archive",
            "text": "After you have built an archive, you can create a Docker image of it and run it in the container.   To create a Docker image from a Ballerina package, you run  ballerina docker  and provide the package name as an argument:  ballerina docker helloWorld.bmz\nballerina: build docker image [helloworld:latest] in docker host [localhost]? (y/n): y\n\nballerina: docker image helloworld:latest successfully built.\n\nUse the following command to start a container.\n        docker run --name determined_aluminum -it helloworld:latest  You can additionally provide a customized image name:  ballerina docker helloWorld.bmz -t myhelloworld:0.1\nballerina: build docker image [myhelloworld:0.1] in docker host [localhost]? (y/n): y\n\nballerina: docker image myhelloworld:0.1 successfully built.\n\nUse the following command to start a container.\n        docker run --name burning_aids -it myhelloworld:0.1  If you want to use a remote Docker daemon, you can specify it using the -H flag so the Docker image is created at the remote end:  ballerina docker helloWorld.bmz -H http://127.0.0.1:2375\nballerina: build docker image [myhelloworld:0.1] in docker host [http://127.0.0.1:2375]? (y/n): y\n\nballerina: docker image helloworld:latest successfully built.\n\nUse the following command to start a container.\n        docker run --name future_aquarium -it helloworld:latest  For more information on the usage of this command, type  ballerina docker --help .",
            "title": "Creating and running a Docker image of the archive"
        },
        {
            "location": "/lang-ref/services/",
            "text": "Services\n\n\nWhen defining a Ballerina program as a service instead of an executable program, the \nservice\n construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that clients use when sending requests to the service. You create one service per Ballerina program file.\n\n\nA service is a container of \nresources\n, each of which defines the logic for handling one type of request. Services are singletons, so all variables defined within a service scope are shared across all resource invocations. A service can have state for as long as it's active. \n\n\nDefining a service\n\n\nTo define a service in the Composer, drag the service icon \n from the tool palette to the canvas. You can then set the base path annotation using the Annotations button in the upper right corner of the service, and define any variables the service needs by clicking the Variables button in the upper left corner. A new resource is added automatically to the service, where you can start adding your integration logic. You can add more resources as needed.\n\n\nA service is defined as follows:\n\n\n[ServiceAnnotations]\nservice ServiceName {\n  ConnectorDeclaration;*\n  VariableDeclaration;*\n  ResourceDefinition;+\n}",
            "title": "Services"
        },
        {
            "location": "/lang-ref/services/#services",
            "text": "When defining a Ballerina program as a service instead of an executable program, the  service  construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that clients use when sending requests to the service. You create one service per Ballerina program file.  A service is a container of  resources , each of which defines the logic for handling one type of request. Services are singletons, so all variables defined within a service scope are shared across all resource invocations. A service can have state for as long as it's active.",
            "title": "Services"
        },
        {
            "location": "/lang-ref/services/#defining-a-service",
            "text": "To define a service in the Composer, drag the service icon   from the tool palette to the canvas. You can then set the base path annotation using the Annotations button in the upper right corner of the service, and define any variables the service needs by clicking the Variables button in the upper left corner. A new resource is added automatically to the service, where you can start adding your integration logic. You can add more resources as needed.  A service is defined as follows:  [ServiceAnnotations]\nservice ServiceName {\n  ConnectorDeclaration;*\n  VariableDeclaration;*\n  ResourceDefinition;+\n}",
            "title": "Defining a service"
        },
        {
            "location": "/lang-ref/resources/",
            "text": "Resources\n\n\nA resource is a construct that handles one request within a \nservice\n. \n\n\nDefining a resource\n\n\nWhen you create a service in Ballerina using the Design view in the Composer, a default resource is automatically created within that service so that you can add your integration logic to it. To add another resource, drag the Resource icon \n to the canvas. \n\n\nA resource is defined as follows:\n\n\n[ResourceAnnotations]\nresource ResourceName (Message VariableName[, ([ResourceParamAnnotations] TypeName VariableName)+]) {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}*\n\n\n\n\nThe visual representation of this (without the annotations) in a sequence diagram is as follows:\n\n\n\n\nIn this example, m1 and m2 are messages that are passed by a client as input to the resources named resource-1 and resource-2, respectively. As a result, resource-1 will produce the message response1, and resource-2 will produce response2. To compute the response message, resource-1 relays message m1 to connector Connector-1 and will receive response1; similarly, resource-2 relays message m2 to connector Connector-2 and will receive response2.\n\n\nA resource can have state, which lasts as long as the resource is active. It can also be a \nworker\n.",
            "title": "Resources"
        },
        {
            "location": "/lang-ref/resources/#resources",
            "text": "A resource is a construct that handles one request within a  service .",
            "title": "Resources"
        },
        {
            "location": "/lang-ref/resources/#defining-a-resource",
            "text": "When you create a service in Ballerina using the Design view in the Composer, a default resource is automatically created within that service so that you can add your integration logic to it. To add another resource, drag the Resource icon   to the canvas.   A resource is defined as follows:  [ResourceAnnotations]\nresource ResourceName (Message VariableName[, ([ResourceParamAnnotations] TypeName VariableName)+]) {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}*  The visual representation of this (without the annotations) in a sequence diagram is as follows:   In this example, m1 and m2 are messages that are passed by a client as input to the resources named resource-1 and resource-2, respectively. As a result, resource-1 will produce the message response1, and resource-2 will produce response2. To compute the response message, resource-1 relays message m1 to connector Connector-1 and will receive response1; similarly, resource-2 relays message m2 to connector Connector-2 and will receive response2.  A resource can have state, which lasts as long as the resource is active. It can also be a  worker .",
            "title": "Defining a resource"
        },
        {
            "location": "/lang-ref/functions/",
            "text": "Functions\n\n\nA function is a single operation that is intended to be a unit of reusable functionality. Ballerina includes a set of native library functions you can call, such as the \nConvertToResponse()\n function you used in the \nWriting your First Program tutorial\n, and you can define additional functions within your Ballerina programs. All library functions are found in \nballerina.*\n packages under the \nsrc\n directory in your Ballerina distribution.  \n\n\nUsing a function\n\n\nTo use a native Ballerina function, scroll down in the tool palette to the package that contains that function, and then drag the function's icon to the canvas. If the function is in another package and is marked public, you can import that package using the Imports box in the upper left corner of the canvas, and then drag the Function Invocation icon to the canvas and call the function: \n\n\n\n\nAll functions are private to the package unless explicitly declared to be public with the \npublic\n keyword. You can invoke functions from a \nresource\n or a function within the same package without importing.\n\n\nDefining a function\n\n\nTo define a new function, drag the Function icon to the canvas. \n\n\nA function is defined as follows:\n\n\n[FunctionAnnotations]\n[public] function FunctionName (((TypeName VariableName)[(, TypeName VariableName)*])?)\n        ((TypeName[(, TypeName)*])?) [throws exception] {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}\n\n\n\n\nA function:\n\n\n\n\nCan have local \nconnectors\n and \nvariables\n\n\nCan return any number of values\n\n\nCan have any number of \nworkers\n\n\nCan be a worker itself",
            "title": "Functions"
        },
        {
            "location": "/lang-ref/functions/#functions",
            "text": "A function is a single operation that is intended to be a unit of reusable functionality. Ballerina includes a set of native library functions you can call, such as the  ConvertToResponse()  function you used in the  Writing your First Program tutorial , and you can define additional functions within your Ballerina programs. All library functions are found in  ballerina.*  packages under the  src  directory in your Ballerina distribution.",
            "title": "Functions"
        },
        {
            "location": "/lang-ref/functions/#using-a-function",
            "text": "To use a native Ballerina function, scroll down in the tool palette to the package that contains that function, and then drag the function's icon to the canvas. If the function is in another package and is marked public, you can import that package using the Imports box in the upper left corner of the canvas, and then drag the Function Invocation icon to the canvas and call the function:    All functions are private to the package unless explicitly declared to be public with the  public  keyword. You can invoke functions from a  resource  or a function within the same package without importing.",
            "title": "Using a function"
        },
        {
            "location": "/lang-ref/functions/#defining-a-function",
            "text": "To define a new function, drag the Function icon to the canvas.   A function is defined as follows:  [FunctionAnnotations]\n[public] function FunctionName (((TypeName VariableName)[(, TypeName VariableName)*])?)\n        ((TypeName[(, TypeName)*])?) [throws exception] {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}  A function:   Can have local  connectors  and  variables  Can return any number of values  Can have any number of  workers  Can be a worker itself",
            "title": "Defining a function"
        },
        {
            "location": "/lang-ref/connectors/",
            "text": "Working with Connectors\n\n\nA connector represents a participant in the integration and is used to interact with an external system or a service you've defined in Ballerina. Ballerina includes a set of connectors under \norg.ballerinalang.connectors.*\n that allow you to connect to Twitter, Facebook, and more. It also includes built-in connectors for network protocols under \nballerina.net.*\n that handle HTTP(S) 1 & 2, WebSockets, JMS, and FTP/FTPS/SFTP.\n\n\nEach connector defines a set of \nactions\n that can be used when interacting with the external system or service. For example, the Twitter connector includes actions such as \ntweet\n, \nretweet\n, and \ndestroyStatus\n, which allow you to perform those actions in Twitter from your Ballerina program.\n\n\nUsing a connector\n\n\nTo use a connector, import it using the Import box in the upper left corner of the canvas in Design view (or use an import statement in the Source view). The connector will then be listed in the tool palette in Ballerina Composer. Scroll down to the connector you want to use, and then drag the connector to the canvas if you want to create an endpoint connection to that service, or drag one of the connector's actions to the place in your integration flow where you want to invoke that action. \n\n\nFor details on using the built-in connectors, see the following topics:\n\n\n\n\nFile Server Connector\n\n\nHTTP/2 Server Connector\n\n\nJMS Client Connector\n\n\nJMS Server Connector\n\n\nWebSocket Server Connector\n\n\n\n\nTo explore other connectors, go to https://github.com/ballerinalang/connectors. \n\n\nDefining a new connector\n\n\nYou can define additional connectors within your Ballerina programs. To define a new connector, drag the Connector Definition icon \n to the canvas. You then drag the Connector Action icon \n to the canvas and define the actions in this connector. \n\n\nA connector is defined as follows:\n\n\n[ConnectorAnnotations]\nconnector ConnectorName ([ConnectorParamAnnotations]TypeName VariableName[(, TypeName VariableName)*]) {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    ActionDefinition;+\n}\n\n\n\n\nThe ConnectorAnnotations are designed to help the editor provide a better user experience for connector users.\n\n\nConnectors are instantiated (by means of the \nnew\n keyword) as follows:\n\n\n[ConnectorPackageName:]ConnectorName ConnectorInstanceName = new [ConnectorPackageName:]ConnectorName (ValueList[, map]);\n\n\n\n\nThe newly created instance has the \nConnectorInstanceName\n assigned.\n\n\nOnce a connector of name \nConnectorInstanceName\n has been instantiated, actions can be invoked against that connector as follows:\n\n\n[ConnectorPackageName:]ConnectorName.ActionName (ConnectorInstanceName, ValueList);\n\n\n\n\nComposing connectors\n\n\nIt is very easy to use one connector to write another connector in Ballerina. For example, the HTTP Basic Auth connector embeds an instance of the HTTP Connector, adds the Basic Auth header, and delegates all work to the underlying connector. This is an excellent approach for writing new connectors, but note that the delegation requires a second function call, which affects performance slightly.\n\n\nUse of connector-scoped variables\n\n\nIn many cases, connectors must keep some state associated with the connection for as long as the connection is valid. Connector-scoped variables are available for this purpose. The \u201cconstructor arguments\u201d given when creating a new connector are also with that same scope.\n\n\nTo define connector-scoped variables, click the Variables button in the upper-left corner of the connector on the canvas. To define constructor arguments, click the connector's Arguments button in the upper-right corner of the connector.",
            "title": "Working with Connectors"
        },
        {
            "location": "/lang-ref/connectors/#working-with-connectors",
            "text": "A connector represents a participant in the integration and is used to interact with an external system or a service you've defined in Ballerina. Ballerina includes a set of connectors under  org.ballerinalang.connectors.*  that allow you to connect to Twitter, Facebook, and more. It also includes built-in connectors for network protocols under  ballerina.net.*  that handle HTTP(S) 1 & 2, WebSockets, JMS, and FTP/FTPS/SFTP.  Each connector defines a set of  actions  that can be used when interacting with the external system or service. For example, the Twitter connector includes actions such as  tweet ,  retweet , and  destroyStatus , which allow you to perform those actions in Twitter from your Ballerina program.",
            "title": "Working with Connectors"
        },
        {
            "location": "/lang-ref/connectors/#using-a-connector",
            "text": "To use a connector, import it using the Import box in the upper left corner of the canvas in Design view (or use an import statement in the Source view). The connector will then be listed in the tool palette in Ballerina Composer. Scroll down to the connector you want to use, and then drag the connector to the canvas if you want to create an endpoint connection to that service, or drag one of the connector's actions to the place in your integration flow where you want to invoke that action.   For details on using the built-in connectors, see the following topics:   File Server Connector  HTTP/2 Server Connector  JMS Client Connector  JMS Server Connector  WebSocket Server Connector   To explore other connectors, go to https://github.com/ballerinalang/connectors.",
            "title": "Using a connector"
        },
        {
            "location": "/lang-ref/connectors/#defining-a-new-connector",
            "text": "You can define additional connectors within your Ballerina programs. To define a new connector, drag the Connector Definition icon   to the canvas. You then drag the Connector Action icon   to the canvas and define the actions in this connector.   A connector is defined as follows:  [ConnectorAnnotations]\nconnector ConnectorName ([ConnectorParamAnnotations]TypeName VariableName[(, TypeName VariableName)*]) {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    ActionDefinition;+\n}  The ConnectorAnnotations are designed to help the editor provide a better user experience for connector users.  Connectors are instantiated (by means of the  new  keyword) as follows:  [ConnectorPackageName:]ConnectorName ConnectorInstanceName = new [ConnectorPackageName:]ConnectorName (ValueList[, map]);  The newly created instance has the  ConnectorInstanceName  assigned.  Once a connector of name  ConnectorInstanceName  has been instantiated, actions can be invoked against that connector as follows:  [ConnectorPackageName:]ConnectorName.ActionName (ConnectorInstanceName, ValueList);",
            "title": "Defining a new connector"
        },
        {
            "location": "/lang-ref/connectors/#composing-connectors",
            "text": "It is very easy to use one connector to write another connector in Ballerina. For example, the HTTP Basic Auth connector embeds an instance of the HTTP Connector, adds the Basic Auth header, and delegates all work to the underlying connector. This is an excellent approach for writing new connectors, but note that the delegation requires a second function call, which affects performance slightly.",
            "title": "Composing connectors"
        },
        {
            "location": "/lang-ref/connectors/#use-of-connector-scoped-variables",
            "text": "In many cases, connectors must keep some state associated with the connection for as long as the connection is valid. Connector-scoped variables are available for this purpose. The \u201cconstructor arguments\u201d given when creating a new connector are also with that same scope.  To define connector-scoped variables, click the Variables button in the upper-left corner of the connector on the canvas. To define constructor arguments, click the connector's Arguments button in the upper-right corner of the connector.",
            "title": "Use of connector-scoped variables"
        },
        {
            "location": "/server-connectors/file-server/",
            "text": "File Server Connector\n\n\nThe File Server connector is used to process files in the specified source directory. Note that files cannot remain in the source directory after processing or they will be processed again. Therefore, after processing a file it will be deleted.\n\n\nDefining a file service\n\n\nStep 1: Create the service\n\n\nCreate a service with unique name.\n\n\nservice orderProcessService {\n\n}\n\n\n\n\nStep 2: Specify service parameters\n\n\nAdd a service level annotation named \nSource\n and add the key-value pairs to specify the parameters. The following section describes each key that can be used with a file service. An example is provided after the tables.\n\n\n\n  \n\n    \nKey\n\n    \nDescription\n\n    \nRequired\n\n    \nExpected Value\n\n    \nDefault value\n\n  \n\n  \n\n    \nprotocol\n\n    \nThe protocol to which this service is bound.\n\n    \nYes\n\n    \nfile\n\n    \n-\n\n  \n\n  \n\n    \nfileURI\n\n    \nThe URI where the files you want to process are located. This can be a URI to a folder. If it is a folder, all the files in the folder will be processed, one at a time. If the URI points to a single file, the file will be processed when it becomes available at that location.\n\n    \nYes\n\n    \nA valid file URI. \n If the file URI contains a user name or a password, make sure that it does not contain '#' or '?' character.\n\n    \n-\n\n  \n\n  \n\n    \npollingInterval\n\n    \nThe polling interval at which the file URI location is polled for the file. The value is expressed in milliseconds.\n\n    \nNo\n\n    \nA positive integer.\n\n    \n10000\n\n  \n\n  \n\n    \nacknowledgementTimeOut\n\n    \nThe expected time in milliseconds that a file needs to stay open until the consumer has finished consuming it. When you develop the Ballerina service, if you are performing time-consuming operations that require the file to be kept open (for example, streaming the file content to a slow backend), this value needs to be set to a higher value accordingly.\n\n    \nNo\n\n    \nA positive integer.\n\n    \n30000\n\n  \n\n  \n\n    \ndeleteIfNotAcknowledged\n\n    \nIf this parameter is set to \"true\", the file will be deleted in case the file consumer did not acknowledge. Otherwise (if set to \"false\") the file will be kept without deleting, so it will be retried to be processed again in the next polling cycle.\n\n    \nNo\n\n    \ntrue or false\n\n    \nfalse\n\n  \n\n\n\n\n\nWhen the \nfileURI\n parameter points to a folder, the user has the option to sort the files, which are currently in this folder, before processing starts. Following are the parameters you can use to configure sorting operations.\n\n\n\n  \n\n    \nKey\n\n    \nDescription\n\n    \nRequired\n\n    \nExpected Value\n\n    \nDefault value\n\n  \n\n  \n\n    \nfileSortAttribute\n\n    \nThe attribute of the file by which the files will be sorted.\n\n    \nNo\n\n    \nOne of the following:\nname, size, lastModifiedTimestamp\n\n    \n-\n\n  \n\n  \n\n    \nfileSortAscending\n\n    \nA Boolean parameter that indicates whether to sort files in ascending order. If set to \"true\", files will be sorted in ascending order. If set to \u201cfalse\u201d, files will be sorted in descending order.\n\n    \nNo\n\n    \ntrue or false\n\n    \ntrue\n\n  \n\n\n\n\n\nExample:\n\n\n@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n}\n\n\n\n\nStep 3: Add a resource\n\n\nAdd a resource under the file service as below:\n\n\n@Source (\n    protocol = \"file\",\n    fileURI = \"file:///home/user/orders\",\n    pollingInterval = \"20000\",\n    fileSortAttribute = \"size\",\n    fileSortAscending = \"false\"\n    )\nservice orderProcessService { \n    resource processOrder (message m) {\n        // file processing logic here.\n    }\n}\n\n\n\n\nIn general, a service can have multiple resources. However, a service of type File is \nrequired to have one and only one resource\n. \n\n\nStep 4: Add file-processing logic\n\n\nWithin the \nresource\n block, specify the file-processing logic. In the example given below, Ballerina functions (\nsystem:println\n, \nmessages:getStringPayload(m)\n, and \nfile:acknowledge(m)\n) are being used to process the file.\n\n\nimport ballerina.lang.messages;\nimport ballerina.lang.system;\nimport ballerina.net.file;\n\n@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n    resource processOrder (message m) {\n        system:println(messages:getStringPayload(m));\n        file:acknowledge(m);\n    }\n}\n\n\n\n\nNote:\n\nHere, \nfile:acknowledge(m)\n is a function that is exclusive for file processing. See the function description below for details. \n\n\nStep 5: Add dependency JARs\n\n\nWhen the \nfileURI\n parameter refers to a location in the local file system, you do not need to add any additional JARs for the file service to work. However, in other cases (for example, when the \nfileURI\n refers to a remote file or a folder that needs to be accessed via FTP), it may be required to add specific JARs to the \n<ballerina_home>/bre/lib\n folder. \n\n\nThe following table indicates which dependency JARs are required for which file-access protocol.\n\n\n\n\n\n\n\n\nDependency\n\n\nRequired For\n\n\n\n\n\n\n\n\n\n\nCommons Compress\n Version 1.9.\n\n\nTAR, Bzip2\n\n\n\n\n\n\nCommons Net\n Version 3.3.\n\n\nFTP\n\n\n\n\n\n\nCommons Httpclient\n Version 3.1. Requires \nCommons Codec\n Version 1.2.\n\n\nHTTP, URI Utils\n\n\n\n\n\n\nJSch\n Version 0.1.51.\n\n\nSFTP\n\n\n\n\n\n\n\n\nNative Ballerina functions for file processing\n\n\nAcknowledge\n\n\nFunction name:\n acknowledge\n\n\nPackage name:\n ballerina.net.file\n\n\nArguments:\n message\n\n\nThe \nacknowledge\n function sends an acknowledgement to the sender of the message, saying that file processing has being finished. \n\n\nIt is important to note that this function \nmust\n be called after the service has finished consuming the message (that is, the file). See below for an example.\n\n\nimport ballerina.lang.messages;\nimport ballerina.lang.system;\nimport ballerina.net.file;\n\n@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n    resource processOrder (message m) {\n        system:println(messages:getStringPayload(m));\n        file:acknowledge(m);\n    }\n}\n\n\n\n\nIn the above example, once a file is found at the given URI, \norderProcessService\n will receive a message. This message contains a reference to the input stream of the file so the service can process the file.\n\n\nThe service will then execute the statements given within the resource block. \n\n\nsystem:println(messages:getStringPayload(m));\n\n\n\n\nThe above line will read the file content as a String and then print it on the console.\n\n\nfile:acknowledge(m);\n\n\n\n\nThe above line sends an acknowledgment to the sender of the message (this sender has the control to close the file input stream). As a result, the file input stream will be closed, and then the file will be deleted. \n\n\nSince this function makes the message sender close the input stream and delete the file, this function needs to be called only after message processing is done. \n\n\nIn case the service does not call the \nacknowledge\n function, the message sender will wait for 30 seconds (30 seconds is the default wait time. This value can be overridden by specifying a different value as the \nacknowledgementTimeOut\n service parameter) and assume that the file was not processed. Following the same assumption, the message sender will not delete the file. As a result of this, the file will remain at the same URI to which the service listens, so it will be attempted to be processed in the next polling cycle as well. This behavior can be changed by setting \ndeleteIfNotAcknowledged\n service parameter to \"true\". If it is set to \"true\" then, the file will be deleted anyway, regardless of whether the acknowledgement was made or not.",
            "title": "File Server Connector"
        },
        {
            "location": "/server-connectors/file-server/#file-server-connector",
            "text": "The File Server connector is used to process files in the specified source directory. Note that files cannot remain in the source directory after processing or they will be processed again. Therefore, after processing a file it will be deleted.",
            "title": "File Server Connector"
        },
        {
            "location": "/server-connectors/file-server/#defining-a-file-service",
            "text": "",
            "title": "Defining a file service"
        },
        {
            "location": "/server-connectors/file-server/#step-1-create-the-service",
            "text": "Create a service with unique name.  service orderProcessService {\n\n}",
            "title": "Step 1: Create the service"
        },
        {
            "location": "/server-connectors/file-server/#step-2-specify-service-parameters",
            "text": "Add a service level annotation named  Source  and add the key-value pairs to specify the parameters. The following section describes each key that can be used with a file service. An example is provided after the tables.  \n   \n     Key \n     Description \n     Required \n     Expected Value \n     Default value \n   \n   \n     protocol \n     The protocol to which this service is bound. \n     Yes \n     file \n     - \n   \n   \n     fileURI \n     The URI where the files you want to process are located. This can be a URI to a folder. If it is a folder, all the files in the folder will be processed, one at a time. If the URI points to a single file, the file will be processed when it becomes available at that location. \n     Yes \n     A valid file URI.   If the file URI contains a user name or a password, make sure that it does not contain '#' or '?' character. \n     - \n   \n   \n     pollingInterval \n     The polling interval at which the file URI location is polled for the file. The value is expressed in milliseconds. \n     No \n     A positive integer. \n     10000 \n   \n   \n     acknowledgementTimeOut \n     The expected time in milliseconds that a file needs to stay open until the consumer has finished consuming it. When you develop the Ballerina service, if you are performing time-consuming operations that require the file to be kept open (for example, streaming the file content to a slow backend), this value needs to be set to a higher value accordingly. \n     No \n     A positive integer. \n     30000 \n   \n   \n     deleteIfNotAcknowledged \n     If this parameter is set to \"true\", the file will be deleted in case the file consumer did not acknowledge. Otherwise (if set to \"false\") the file will be kept without deleting, so it will be retried to be processed again in the next polling cycle. \n     No \n     true or false \n     false \n     When the  fileURI  parameter points to a folder, the user has the option to sort the files, which are currently in this folder, before processing starts. Following are the parameters you can use to configure sorting operations.  \n   \n     Key \n     Description \n     Required \n     Expected Value \n     Default value \n   \n   \n     fileSortAttribute \n     The attribute of the file by which the files will be sorted. \n     No \n     One of the following:\nname, size, lastModifiedTimestamp \n     - \n   \n   \n     fileSortAscending \n     A Boolean parameter that indicates whether to sort files in ascending order. If set to \"true\", files will be sorted in ascending order. If set to \u201cfalse\u201d, files will be sorted in descending order. \n     No \n     true or false \n     true",
            "title": "Step 2: Specify service parameters"
        },
        {
            "location": "/server-connectors/file-server/#example",
            "text": "@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n}",
            "title": "Example:"
        },
        {
            "location": "/server-connectors/file-server/#step-3-add-a-resource",
            "text": "Add a resource under the file service as below:  @Source (\n    protocol = \"file\",\n    fileURI = \"file:///home/user/orders\",\n    pollingInterval = \"20000\",\n    fileSortAttribute = \"size\",\n    fileSortAscending = \"false\"\n    )\nservice orderProcessService { \n    resource processOrder (message m) {\n        // file processing logic here.\n    }\n}  In general, a service can have multiple resources. However, a service of type File is  required to have one and only one resource .",
            "title": "Step 3: Add a resource"
        },
        {
            "location": "/server-connectors/file-server/#step-4-add-file-processing-logic",
            "text": "Within the  resource  block, specify the file-processing logic. In the example given below, Ballerina functions ( system:println ,  messages:getStringPayload(m) , and  file:acknowledge(m) ) are being used to process the file.  import ballerina.lang.messages;\nimport ballerina.lang.system;\nimport ballerina.net.file;\n\n@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n    resource processOrder (message m) {\n        system:println(messages:getStringPayload(m));\n        file:acknowledge(m);\n    }\n}  Note: \nHere,  file:acknowledge(m)  is a function that is exclusive for file processing. See the function description below for details.",
            "title": "Step 4: Add file-processing logic"
        },
        {
            "location": "/server-connectors/file-server/#step-5-add-dependency-jars",
            "text": "When the  fileURI  parameter refers to a location in the local file system, you do not need to add any additional JARs for the file service to work. However, in other cases (for example, when the  fileURI  refers to a remote file or a folder that needs to be accessed via FTP), it may be required to add specific JARs to the  <ballerina_home>/bre/lib  folder.   The following table indicates which dependency JARs are required for which file-access protocol.     Dependency  Required For      Commons Compress  Version 1.9.  TAR, Bzip2    Commons Net  Version 3.3.  FTP    Commons Httpclient  Version 3.1. Requires  Commons Codec  Version 1.2.  HTTP, URI Utils    JSch  Version 0.1.51.  SFTP",
            "title": "Step 5: Add dependency JARs"
        },
        {
            "location": "/server-connectors/file-server/#native-ballerina-functions-for-file-processing",
            "text": "",
            "title": "Native Ballerina functions for file processing"
        },
        {
            "location": "/server-connectors/file-server/#acknowledge",
            "text": "Function name:  acknowledge  Package name:  ballerina.net.file  Arguments:  message  The  acknowledge  function sends an acknowledgement to the sender of the message, saying that file processing has being finished.   It is important to note that this function  must  be called after the service has finished consuming the message (that is, the file). See below for an example.  import ballerina.lang.messages;\nimport ballerina.lang.system;\nimport ballerina.net.file;\n\n@Source (\n  protocol = \"file\",\n  fileURI = \"file:///home/user/orders\",\n  pollingInterval = \"20000\",\n  fileSortAttribute = \"size\",\n  fileSortAscending = \"false\"\n  )\nservice orderProcessService {\n    resource processOrder (message m) {\n        system:println(messages:getStringPayload(m));\n        file:acknowledge(m);\n    }\n}  In the above example, once a file is found at the given URI,  orderProcessService  will receive a message. This message contains a reference to the input stream of the file so the service can process the file.  The service will then execute the statements given within the resource block.   system:println(messages:getStringPayload(m));  The above line will read the file content as a String and then print it on the console.  file:acknowledge(m);  The above line sends an acknowledgment to the sender of the message (this sender has the control to close the file input stream). As a result, the file input stream will be closed, and then the file will be deleted.   Since this function makes the message sender close the input stream and delete the file, this function needs to be called only after message processing is done.   In case the service does not call the  acknowledge  function, the message sender will wait for 30 seconds (30 seconds is the default wait time. This value can be overridden by specifying a different value as the  acknowledgementTimeOut  service parameter) and assume that the file was not processed. Following the same assumption, the message sender will not delete the file. As a result of this, the file will remain at the same URI to which the service listens, so it will be attempted to be processed in the next polling cycle as well. This behavior can be changed by setting  deleteIfNotAcknowledged  service parameter to \"true\". If it is set to \"true\" then, the file will be deleted anyway, regardless of whether the acknowledgement was made or not.",
            "title": "Acknowledge"
        },
        {
            "location": "/server-connectors/http2-server/",
            "text": "HTTP/2 Server Connector\n\n\nAbout HTTP/2\n\n\nThe Hypertext Transfer Protocol (HTTP) is a wildly successful protocol,  but still has some weaknesses with HTTP 1.0 and 1.1 versions.\n\n\nHTTP/2 was introduced to address those drawbacks with features of Binary information exchange, compressed headers, multiplexing, and Server Push.\n\n\nHTTP/2 Server Connector\n\n\nThe HTTP/2 server connector allows Ballerina programmers to expose their APIs to HTTP/2 clients. So when you send an HTTP request using an HTTP/2 client, the server will upgrade the protocol to HTTP/2 and send the response as below.\n\n\nHTTP/1.1 101 Switching Protocols\nConnection: upgrade\nUpgrade:h2c\nHTTP/2.0 200\nHttp-to-http2-upgrade true\n\n\n\n\nThen server will send a response to the user request through the HTTP/2 protocol.\n\n\nHow to define an HTTP/2 service\n\n\nYou can design the service the same as an HTTP service and deploy it in the Ballerina server. The service will be served with both HTTP/1 and HTTP/2 clients after enabling HTTP/2 Support.\n\n\nHTTP/1 > Ballerina > response with HTTP/1\nHTTP/2 > Ballerina > response with HTTP/2\nHTTPS  > Ballerina >  response with HTTP/1\nHTTPS/2 > Ballerina >  response with HTTP/2\n\n\n\n\nHTTP/2 Multiplexing\n\n\nHTTP/2 Multiplexing allows users to send multiple requests with the same TCP connection using multiple streams. One stream will have the request-response model.\n\n\nBallerina provides an example \nHTTP/2 Java client\n and \ntest samples\n. The test code uses the same HTTPClient \nconnection to send multiple requests.\n\n\nEnable the HTTP/2 transport\n\n\nHTTP/2 is disabled by default. Follow these steps to initiate HTTP/2.\n\n\nConfigure the listener\n\n\nOpen the \n$BALLERINA_HOME/bre/conf/netty-transports.yml\n file and add the following line to the given interface ID in the listenerConfigurations section. You can enable http2 in multiple interfaces as well, e.g., HTTP and HTTPS.\n\n\nhttp2: true\n\n\n\n\nFor example:\n\n\nid: \"default\"\nhost: \"0.0.0.0\"\nport: 9090\nhttp2: true\n\n\n\n\nDownload the ALPN agent\n\n\nHTTP/2 over TLS requires the use of ALPN to negotiate the use of the h2 protocol. Java does not currently support ALPN, which will be supported in the next Java version. For lack of support in the JDK we need to use the Jetty-ALPN  bootclasspath extension.\n\n\nYou can download the \njetty-alpn-agent\n and set the Java agent in the \n$BALLERINA_HOME/bin/ballerina\n file as follows:\n\n\n-javaagent:(path_to_jetty-alpn-agent.jar)\\\n\n\n\n\nFor example:\n\n\n-javaagent:\"$BALLERINA_HOME/bre/lib/jetty-alpn-agent-2.0.6.jar\"\\\n\n\n\n\n\n\nNOTE: The java-agent has all the class path extensions of different JDK versions. But you can use the release of the Jetty-ALPN JAR specific to the version of Java you are using and Xbootclasspath the JVM option referencing the path to the Jetty alpn-boot JAR. See the \nNetty documentation\n for other SSL options.\n\n\n\n\nTest the HTTP/2 service\n\n\nYou can use an HTTP/2 client to test the HTTP/2 services. See the example \nHTTP/2 Java client\n and \ntest samples\n to see how to call HTTP samples using an HTTP/2 Java client.",
            "title": "HTTP/2 Server Connector"
        },
        {
            "location": "/server-connectors/http2-server/#http2-server-connector",
            "text": "",
            "title": "HTTP/2 Server Connector"
        },
        {
            "location": "/server-connectors/http2-server/#about-http2",
            "text": "The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol,  but still has some weaknesses with HTTP 1.0 and 1.1 versions.  HTTP/2 was introduced to address those drawbacks with features of Binary information exchange, compressed headers, multiplexing, and Server Push.",
            "title": "About HTTP/2"
        },
        {
            "location": "/server-connectors/http2-server/#http2-server-connector_1",
            "text": "The HTTP/2 server connector allows Ballerina programmers to expose their APIs to HTTP/2 clients. So when you send an HTTP request using an HTTP/2 client, the server will upgrade the protocol to HTTP/2 and send the response as below.  HTTP/1.1 101 Switching Protocols\nConnection: upgrade\nUpgrade:h2c\nHTTP/2.0 200\nHttp-to-http2-upgrade true  Then server will send a response to the user request through the HTTP/2 protocol.",
            "title": "HTTP/2 Server Connector"
        },
        {
            "location": "/server-connectors/http2-server/#how-to-define-an-http2-service",
            "text": "You can design the service the same as an HTTP service and deploy it in the Ballerina server. The service will be served with both HTTP/1 and HTTP/2 clients after enabling HTTP/2 Support.  HTTP/1 > Ballerina > response with HTTP/1\nHTTP/2 > Ballerina > response with HTTP/2\nHTTPS  > Ballerina >  response with HTTP/1\nHTTPS/2 > Ballerina >  response with HTTP/2",
            "title": "How to define an HTTP/2 service"
        },
        {
            "location": "/server-connectors/http2-server/#http2-multiplexing",
            "text": "HTTP/2 Multiplexing allows users to send multiple requests with the same TCP connection using multiple streams. One stream will have the request-response model.  Ballerina provides an example  HTTP/2 Java client  and  test samples . The test code uses the same HTTPClient \nconnection to send multiple requests.",
            "title": "HTTP/2 Multiplexing"
        },
        {
            "location": "/server-connectors/http2-server/#enable-the-http2-transport",
            "text": "HTTP/2 is disabled by default. Follow these steps to initiate HTTP/2.",
            "title": "Enable the HTTP/2 transport"
        },
        {
            "location": "/server-connectors/http2-server/#configure-the-listener",
            "text": "Open the  $BALLERINA_HOME/bre/conf/netty-transports.yml  file and add the following line to the given interface ID in the listenerConfigurations section. You can enable http2 in multiple interfaces as well, e.g., HTTP and HTTPS.  http2: true  For example:  id: \"default\"\nhost: \"0.0.0.0\"\nport: 9090\nhttp2: true",
            "title": "Configure the listener"
        },
        {
            "location": "/server-connectors/http2-server/#download-the-alpn-agent",
            "text": "HTTP/2 over TLS requires the use of ALPN to negotiate the use of the h2 protocol. Java does not currently support ALPN, which will be supported in the next Java version. For lack of support in the JDK we need to use the Jetty-ALPN  bootclasspath extension.  You can download the  jetty-alpn-agent  and set the Java agent in the  $BALLERINA_HOME/bin/ballerina  file as follows:  -javaagent:(path_to_jetty-alpn-agent.jar)\\  For example:  -javaagent:\"$BALLERINA_HOME/bre/lib/jetty-alpn-agent-2.0.6.jar\"\\   NOTE: The java-agent has all the class path extensions of different JDK versions. But you can use the release of the Jetty-ALPN JAR specific to the version of Java you are using and Xbootclasspath the JVM option referencing the path to the Jetty alpn-boot JAR. See the  Netty documentation  for other SSL options.",
            "title": "Download the ALPN agent"
        },
        {
            "location": "/server-connectors/http2-server/#test-the-http2-service",
            "text": "You can use an HTTP/2 client to test the HTTP/2 services. See the example  HTTP/2 Java client  and  test samples  to see how to call HTTP samples using an HTTP/2 Java client.",
            "title": "Test the HTTP/2 service"
        },
        {
            "location": "/server-connectors/jms-client/",
            "text": "JMS Client Connector\n\n\nThe JMS client connector can be used to send/publish JMS messages to a JMS broker. Given below is a diagram that represents a high-level view of the connector.\n\n\n\n\nDefining a JMS service\n\n\nStep 1\n\n\nCreate a Ballerina resource or a function and import the \nballerina.net.jms\n package.\n\n\nStep 2\n\n\nInitialize a JMS connector instance by passing the following parameters. This can be done inside either a Ballerina function or a Ballerina resource.\n\n\nExpected values\n\n\n\n\n\n\n\n\nParameter Name\n\n\nParameter Type\n\n\nDescription\n\n\nExpected Values\n\n\n\n\n\n\n\n\n\n\nFactoryInitial\n\n\nstring\n\n\nThe JNDI initial context factory class. The class must implement the \njava.naming.spi.InitialContextFactory\n interface.\n\n\nA valid class name depending on the JMS provider\n\n\n\n\n\n\nProviderURL\n\n\nstring\n\n\nThe URL/file path of the JNDI provider.\n\n\nA valid URL/path for the JNDI provider\n\n\n\n\n\n\n\n\nExample:\n\n\njms:ClientConnector jmsEP = create jms:ClientConnector(\"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\", \"jndi.properties\");\n\n\n\n\nStep 3\n\n\nInvoke the send action of the JMS client connector and pass the relevant parameters as mentioned below.\n\n\n\n\n\n\n\n\nParameter Name\n\n\nParameter type\n\n\nDescription\n\n\nExpected Values\n\n\n\n\n\n\n\n\n\n\nJMSConnector\n\n\nJMSConnector\n\n\nA JMSConnector instance\n\n\nA JMSConnector instance that has been initialized\n\n\n\n\n\n\nConnectionFactoryName\n\n\nstring\n\n\nThe JNDI name of the connection factory\n\n\n-\n\n\n\n\n\n\nDestinationName\n\n\nstring\n\n\nThe JNDI name of the destination\n\n\nThe JNDI name of the destination\n\n\n\n\n\n\nDestinationType\n\n\nstring\n\n\nThe type of the destinaiton\n\n\nThe queue or topic. If not given, taken as queue.\n\n\n\n\n\n\nMessageType\n\n\nstring\n\n\nThe message type needed to be sent\n\n\nMessage, TextMessage, BytesMessage, ObjectMessage, or MapMessage\n\n\n\n\n\n\nMessage\n\n\nmessage\n\n\nThe message conaining the payload to be sent\n\n\nA Ballerina message\n\n\n\n\n\n\nPropertyMap\n\n\nmap\n\n\nA map of optional Ballerina properties\n\n\nA valid Ballerina map\n\n\n\n\n\n\n\n\nOptional parameters that can be defined in PropertyMap:\n\n\n\n\n\n\n\n\nParameter Name\n\n\nParameter type\n\n\nDescription\n\n\nExpected Values\n\n\n\n\n\n\n\n\n\n\nConnectionUsername\n\n\nstring\n\n\nA valid connection username to connect to the JMS provider\n\n\nValid string username\n\n\n\n\n\n\nConnectionPassword\n\n\nstring\n\n\nA valid connection password to connect to the JMS provider\n\n\nValid string password\n\n\n\n\n\n\nMapData\n\n\nmap\n\n\nMap of data to send in a JMS map message\n\n\nMap of data to send in a JMS map message, only if message type is MapMessage\n\n\n\n\n\n\nConnectionCacheLevel\n\n\nint\n\n\nCaching level required when sending messages\n\n\n0 - No caching (default), 1 - Cache Connection, 2 - Cache Session, 3 - Cache Consumer, or 4 - Cache Producer\n\n\n\n\n\n\n\n\nExample:\n\n\nmessage queueMessage = {};\nmap dataMap;\ndataMap = {};\nmessages:setStringPayload(queueMessage, \"Hello from ballerina\");\njms:ClientConnector.send(jmsEP, \"QueueConnectionFactory\", \"MyQueue\", \"queue\", \"TextMessage\", queueMessage, dataMap);\n\n\n\n\nGiven below is a sample Ballerina function depicting the creation of a JMS client connector:\n\n\njms:ClientConnector jmsEP = create jms:ClientConnector(\"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\", \"jndi.properties\");\nmessage queueMessage = {};\nmap dataMap;\ndataMap = { \"country\" : \"US\", \"currency\" : \"Dollar\" , \"states\" : \"50\"};\nmap propertyMap;\npropertyMap = { \"MapData\" : dataMap};\njms:ClientConnector.send(jmsEP, \"QueueConnectionFactory\", \"MyQueue\", \"queue\", \"MapMessage\", queueMessage, propertyMap);",
            "title": "JMS Client Connector"
        },
        {
            "location": "/server-connectors/jms-client/#jms-client-connector",
            "text": "The JMS client connector can be used to send/publish JMS messages to a JMS broker. Given below is a diagram that represents a high-level view of the connector.",
            "title": "JMS Client Connector"
        },
        {
            "location": "/server-connectors/jms-client/#defining-a-jms-service",
            "text": "",
            "title": "Defining a JMS service"
        },
        {
            "location": "/server-connectors/jms-client/#step-1",
            "text": "Create a Ballerina resource or a function and import the  ballerina.net.jms  package.",
            "title": "Step 1"
        },
        {
            "location": "/server-connectors/jms-client/#step-2",
            "text": "Initialize a JMS connector instance by passing the following parameters. This can be done inside either a Ballerina function or a Ballerina resource.",
            "title": "Step 2"
        },
        {
            "location": "/server-connectors/jms-client/#expected-values",
            "text": "Parameter Name  Parameter Type  Description  Expected Values      FactoryInitial  string  The JNDI initial context factory class. The class must implement the  java.naming.spi.InitialContextFactory  interface.  A valid class name depending on the JMS provider    ProviderURL  string  The URL/file path of the JNDI provider.  A valid URL/path for the JNDI provider     Example:  jms:ClientConnector jmsEP = create jms:ClientConnector(\"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\", \"jndi.properties\");",
            "title": "Expected values"
        },
        {
            "location": "/server-connectors/jms-client/#step-3",
            "text": "Invoke the send action of the JMS client connector and pass the relevant parameters as mentioned below.     Parameter Name  Parameter type  Description  Expected Values      JMSConnector  JMSConnector  A JMSConnector instance  A JMSConnector instance that has been initialized    ConnectionFactoryName  string  The JNDI name of the connection factory  -    DestinationName  string  The JNDI name of the destination  The JNDI name of the destination    DestinationType  string  The type of the destinaiton  The queue or topic. If not given, taken as queue.    MessageType  string  The message type needed to be sent  Message, TextMessage, BytesMessage, ObjectMessage, or MapMessage    Message  message  The message conaining the payload to be sent  A Ballerina message    PropertyMap  map  A map of optional Ballerina properties  A valid Ballerina map     Optional parameters that can be defined in PropertyMap:     Parameter Name  Parameter type  Description  Expected Values      ConnectionUsername  string  A valid connection username to connect to the JMS provider  Valid string username    ConnectionPassword  string  A valid connection password to connect to the JMS provider  Valid string password    MapData  map  Map of data to send in a JMS map message  Map of data to send in a JMS map message, only if message type is MapMessage    ConnectionCacheLevel  int  Caching level required when sending messages  0 - No caching (default), 1 - Cache Connection, 2 - Cache Session, 3 - Cache Consumer, or 4 - Cache Producer     Example:  message queueMessage = {};\nmap dataMap;\ndataMap = {};\nmessages:setStringPayload(queueMessage, \"Hello from ballerina\");\njms:ClientConnector.send(jmsEP, \"QueueConnectionFactory\", \"MyQueue\", \"queue\", \"TextMessage\", queueMessage, dataMap);  Given below is a sample Ballerina function depicting the creation of a JMS client connector:  jms:ClientConnector jmsEP = create jms:ClientConnector(\"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\", \"jndi.properties\");\nmessage queueMessage = {};\nmap dataMap;\ndataMap = { \"country\" : \"US\", \"currency\" : \"Dollar\" , \"states\" : \"50\"};\nmap propertyMap;\npropertyMap = { \"MapData\" : dataMap};\njms:ClientConnector.send(jmsEP, \"QueueConnectionFactory\", \"MyQueue\", \"queue\", \"MapMessage\", queueMessage, propertyMap);",
            "title": "Step 3"
        },
        {
            "location": "/server-connectors/jms-server/",
            "text": "JMS Server Connector\n\n\nThe JMS Server connector can be used to listen to a topic/queue in a JNDI-based JMS provider. Following is a high-level view on how the JMS Server connector works:\n\n\n\n\nHow to write a JMS service\n\n\nStep 1: Create the service\n\n\nCreate a service with unique name.\n\n\nExample: \n\n\nservice jmsService {\n}\n\n\n\n\nStep 2: Specify the connection details\n\n\nAdd a service-level annotation named \u201cjms:JMSSource\u201d, and add the key-value pairs of these two mandatory properties to specify the JMS connection details.\nThe following table describes each key that can be used with the JMS service.\n\n\n\n\n\n\n\n\nKey\n\n\nDescription\n\n\nExpected Values\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nfactoryInitial\n\n\nThe JNDI initial context factory class. The class must implement the java.naming.spi.InitialContextFactory interface.\n\n\nA valid class name depending on the JMS provider\n\n\n-\n\n\n\n\n\n\nproviderUrl\n\n\nThe URL/ file path of the JNDI provider\n\n\nA valid URL/ path for the JNDI provider\n\n\n-\n\n\n\n\n\n\n\n\nExample: \n\n\nimport ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\"}\n\n\n\n\nThe following set of parameters are optional and can be provided to the JMS provider along with any other vendor specific properties by adding an annotation named \"jms:ConnectionProperty\"\n\n\n\n\n\n\n\n\nKey\n\n\nDescription\n\n\nRequired\n\n\nExpected Values\n\n\nDefault Value\n\n\n\n\n\n\n\n\n\n\nconnectionFactoryType\n\n\nThe type of the connection factory\n\n\nno\n\n\nqueue, topic\n\n\nqueue\n\n\n\n\n\n\nconnectionFactoryJNDIName\n\n\nThe JNDI name of the connection factory\n\n\nYes\n\n\nA valid JNDI name of the connection factory.\n\n\n-\n\n\n\n\n\n\ndestination\n\n\nThe JNDI name of the destination\n\n\nno\n\n\nA valid JNDI name of the destination\n\n\nservice name\n\n\n\n\n\n\nsessionAcknowledgement\n\n\nThe JMS session acknowledgment mode\n\n\nno\n\n\nAUTO_ACKNOWLEDGE, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE, SESSION_TRANSACTED\n\n\nAUTO_ACKNOWLEDGE\n\n\n\n\n\n\nconnectionUsername\n\n\nThe JMS connection username\n\n\nno\n\n\n-\n\n\n-\n\n\n\n\n\n\nconnectionPassword\n\n\nThe JMS connection password\n\n\nno\n\n\n-\n\n\n-\n\n\n\n\n\n\nsubscriptionDurable\n\n\nWhether subscription is durable\n\n\nno\n\n\ntrue/false\n\n\nfalse (subscription is not durable)\n\n\n\n\n\n\ndurableSubscriberClientID\n\n\nThe ClientId parameter when using durable subscriptions\n\n\nRequired if subscriptionDurable is specified as \"true\"\n\n\n-\n\n\n-\n\n\n\n\n\n\ndurableSubscriberName\n\n\nThe name of the durable subscriber\n\n\nRequired if subscriptionDurable is specified as \"true\"\n\n\n-\n\n\n-\n\n\n\n\n\n\nretryInterval\n\n\nThe retry interval (in milliseconds) if the JMS connection cannot be established at the beginning or is lost in the middle\n\n\nno\n\n\nA valid long value\n\n\n10000\n\n\n\n\n\n\nmaxRetryCount\n\n\nMaximum retry count if the JMS connection cannot be established at the beginning or is lost in the middle\n\n\nno\n\n\nA valid integer value\n\n\n5\n\n\n\n\n\n\nuseReceiver\n\n\nUse synchronous message receiver to receive message instead of asynchronous message listener\n\n\nno\n\n\ntrue/false\n\n\nfalse\n\n\n\n\n\n\n\n\nExample: \n\n\nimport ballerina.net.jms;\n\n@jms:ConnectionProperty{key:\"connectionFactoryType\", value:\"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}\n\n\n\n\nStep 3: Add the resource\n\n\nAdd a resource to the JMS service. This is required, because whenever a message comes from the JMS provider to a specific JMS service, it will be delivered to this particular resource. You must have only one resource in a JMS service.\n\n\nExample:\n\n\nimport ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\",\nconnectionFactoryType : \"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}\nservice jmsService {\n    resource onMessage (message m) {\n        // ProcessMessage\n    }\n\n\n\n\nNow you will have a JMS service that can be deployed to the Ballerina server. \n\n\n\n\nNOTE: Before deploying the JMS service, you must copy the client-libs provided by the JMS provider to \n{Ballerina_HOME}/bre/lib\n \n\n\n\n\nFollowing is a sample JMS service.\n\n\nimport ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\"}\n@jms:ConnectionProperty{key:\"connectionFactoryType\", value:\"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}\nservice jmsService {\n    resource onMessage (message m) {\n        //Process the message\n        jms:acknowledge(m, \"SUCCESS\");\n    }\n}\n\n\n\n\nBallerina Native Functions\n\n\nThis section describes the native functions you can use to work with JMS messages.\n\n\nPackage ballerina.lang.messages\n\n\nmessages:getHeader\n\n\nThis function can be used to get the value of the particular JMS header. It accepts the following parameters:    \n\n\n\n\nRelevant message to get the header from\n\n\nHeader name\n\n\n\n\nExample:\n\n\nimport ballerina.lang.messages\n---\nstring jmsMessageId;\njmsMessageId = messages:getHeader(m, \"JMS_MESSAGE_ID\");\n\n\n\n\nmessages:getStringPayload\n\n\nThis function can be used to get the string payload of the JMS text message or bytes message. This function accepts the relevant Ballerina message as the parameter. It will return the string payload of the relevant message.\n\n\nExample:\n\n\nimport ballerina.lang.messages\n---\nstring stringPayload;\nstringPayload = messages:getStringPayload(m);\n\n\n\n\nmessages:getStringValue\n\n\nThis function can be used to get the string value of a specific map key in a map type message. This function accepts the following:\n\n\n\n\nRelevant Ballerina message to get the string value from\n\n\nRelevant map key value\n\n\n\n\nExample: \n\n\nimport ballerina.lang.messages\n---\nstring stringValue;\nstringValue = messages:getStringValue(m, \u201ccount\u201d);\n\n\n\n\nmessages:getProperty\n\n\nThis function can be used to retrieve a property from the message.\n\n\nExample:\n\n\nMessage type can be retrieved from the message as below.\n\n\nimport ballerina.lang.messages;\n---\n\nstring msgType = messages:getProperty(m, \"JMS_MESSAGE_TYPE\");\n\n\n\n\n\nPackage ballerina.net.jms\n\n\njms:acknowledge\n\n\nThis function can be used to acknowledge the message delivery or success, which is particularly useful when using the client acknowledgement mode. This function accepts the following parameters:\n\n\n\n\nBallerina message that needs to be acknowledged \n\n\nMessage delivery status - \u201cSUCCESS\u201d or  \u201cERROR\u201d\n\n\n\n\nExample:\n\n\nimport ballerina.net.jms\n---\njms:acknowledge(m, \"SUCCESS\");\n\n\n\n\njms:commit\n\n\nThis function can be used to commit the JMS session when using the session acknowledgement mode. This function accepts one parameter: the relevant message that the user wants to acknowledge the session with.\n\n\nExample: \n\n\nimport ballerina.net.jms\n---\njms:commit();\n\n\n\n\njms:rollback\n\n\nThis function can be used to commit the messages when using the session acknowledgement mode. This function accepts one parameter: the relevant Ballerina message that the user wants to roll back the session with.\n\n\nExample:\n\n\nimport ballerina.net.jms\n---\njms:rollback();",
            "title": "JMS Server Connector"
        },
        {
            "location": "/server-connectors/jms-server/#jms-server-connector",
            "text": "The JMS Server connector can be used to listen to a topic/queue in a JNDI-based JMS provider. Following is a high-level view on how the JMS Server connector works:",
            "title": "JMS Server Connector"
        },
        {
            "location": "/server-connectors/jms-server/#how-to-write-a-jms-service",
            "text": "",
            "title": "How to write a JMS service"
        },
        {
            "location": "/server-connectors/jms-server/#step-1-create-the-service",
            "text": "Create a service with unique name.  Example:   service jmsService {\n}",
            "title": "Step 1: Create the service"
        },
        {
            "location": "/server-connectors/jms-server/#step-2-specify-the-connection-details",
            "text": "Add a service-level annotation named \u201cjms:JMSSource\u201d, and add the key-value pairs of these two mandatory properties to specify the JMS connection details.\nThe following table describes each key that can be used with the JMS service.     Key  Description  Expected Values  Default Value      factoryInitial  The JNDI initial context factory class. The class must implement the java.naming.spi.InitialContextFactory interface.  A valid class name depending on the JMS provider  -    providerUrl  The URL/ file path of the JNDI provider  A valid URL/ path for the JNDI provider  -     Example:   import ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\"}  The following set of parameters are optional and can be provided to the JMS provider along with any other vendor specific properties by adding an annotation named \"jms:ConnectionProperty\"     Key  Description  Required  Expected Values  Default Value      connectionFactoryType  The type of the connection factory  no  queue, topic  queue    connectionFactoryJNDIName  The JNDI name of the connection factory  Yes  A valid JNDI name of the connection factory.  -    destination  The JNDI name of the destination  no  A valid JNDI name of the destination  service name    sessionAcknowledgement  The JMS session acknowledgment mode  no  AUTO_ACKNOWLEDGE, CLIENT_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE, SESSION_TRANSACTED  AUTO_ACKNOWLEDGE    connectionUsername  The JMS connection username  no  -  -    connectionPassword  The JMS connection password  no  -  -    subscriptionDurable  Whether subscription is durable  no  true/false  false (subscription is not durable)    durableSubscriberClientID  The ClientId parameter when using durable subscriptions  Required if subscriptionDurable is specified as \"true\"  -  -    durableSubscriberName  The name of the durable subscriber  Required if subscriptionDurable is specified as \"true\"  -  -    retryInterval  The retry interval (in milliseconds) if the JMS connection cannot be established at the beginning or is lost in the middle  no  A valid long value  10000    maxRetryCount  Maximum retry count if the JMS connection cannot be established at the beginning or is lost in the middle  no  A valid integer value  5    useReceiver  Use synchronous message receiver to receive message instead of asynchronous message listener  no  true/false  false     Example:   import ballerina.net.jms;\n\n@jms:ConnectionProperty{key:\"connectionFactoryType\", value:\"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}",
            "title": "Step 2: Specify the connection details"
        },
        {
            "location": "/server-connectors/jms-server/#step-3-add-the-resource",
            "text": "Add a resource to the JMS service. This is required, because whenever a message comes from the JMS provider to a specific JMS service, it will be delivered to this particular resource. You must have only one resource in a JMS service.  Example:  import ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\",\nconnectionFactoryType : \"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}\nservice jmsService {\n    resource onMessage (message m) {\n        // ProcessMessage\n    }  Now you will have a JMS service that can be deployed to the Ballerina server.    NOTE: Before deploying the JMS service, you must copy the client-libs provided by the JMS provider to  {Ballerina_HOME}/bre/lib     Following is a sample JMS service.  import ballerina.net.jms;\n\n@jms:JMSSource {\nfactoryInitial : \"org.wso2.andes.jndi.PropertiesFileInitialContextFactory\",\nproviderUrl : \"/Users/Akalanka/test/jndi.properties\"}\n@jms:ConnectionProperty{key:\"connectionFactoryType\", value:\"queue\"}\n@jms:ConnectionProperty{key:\"destination\", value:\"MyQueue\"}\n@jms:ConnectionProperty{key:\"useReceiver\", value:\"true\"}\n@jms:ConnectionProperty{key:\"connectionFactoryJNDIName\", value:\"QueueConnectionFactory\"}\n@jms:ConnectionProperty{key:\"sessionAcknowledgement\", value:\"AUTO_ACKNOWLEDGE\"}\nservice jmsService {\n    resource onMessage (message m) {\n        //Process the message\n        jms:acknowledge(m, \"SUCCESS\");\n    }\n}",
            "title": "Step 3: Add the resource"
        },
        {
            "location": "/server-connectors/jms-server/#ballerina-native-functions",
            "text": "This section describes the native functions you can use to work with JMS messages.",
            "title": "Ballerina Native Functions"
        },
        {
            "location": "/server-connectors/jms-server/#package-ballerinalangmessages",
            "text": "messages:getHeader  This function can be used to get the value of the particular JMS header. It accepts the following parameters:       Relevant message to get the header from  Header name   Example:  import ballerina.lang.messages\n---\nstring jmsMessageId;\njmsMessageId = messages:getHeader(m, \"JMS_MESSAGE_ID\");  messages:getStringPayload  This function can be used to get the string payload of the JMS text message or bytes message. This function accepts the relevant Ballerina message as the parameter. It will return the string payload of the relevant message.  Example:  import ballerina.lang.messages\n---\nstring stringPayload;\nstringPayload = messages:getStringPayload(m);  messages:getStringValue  This function can be used to get the string value of a specific map key in a map type message. This function accepts the following:   Relevant Ballerina message to get the string value from  Relevant map key value   Example:   import ballerina.lang.messages\n---\nstring stringValue;\nstringValue = messages:getStringValue(m, \u201ccount\u201d);  messages:getProperty  This function can be used to retrieve a property from the message.  Example:  Message type can be retrieved from the message as below.  import ballerina.lang.messages;\n---\n\nstring msgType = messages:getProperty(m, \"JMS_MESSAGE_TYPE\");",
            "title": "Package ballerina.lang.messages"
        },
        {
            "location": "/server-connectors/jms-server/#package-ballerinanetjms",
            "text": "jms:acknowledge  This function can be used to acknowledge the message delivery or success, which is particularly useful when using the client acknowledgement mode. This function accepts the following parameters:   Ballerina message that needs to be acknowledged   Message delivery status - \u201cSUCCESS\u201d or  \u201cERROR\u201d   Example:  import ballerina.net.jms\n---\njms:acknowledge(m, \"SUCCESS\");  jms:commit  This function can be used to commit the JMS session when using the session acknowledgement mode. This function accepts one parameter: the relevant message that the user wants to acknowledge the session with.  Example:   import ballerina.net.jms\n---\njms:commit();  jms:rollback  This function can be used to commit the messages when using the session acknowledgement mode. This function accepts one parameter: the relevant Ballerina message that the user wants to roll back the session with.  Example:  import ballerina.net.jms\n---\njms:rollback();",
            "title": "Package ballerina.net.jms"
        },
        {
            "location": "/server-connectors/websocket-server/",
            "text": "WebSocket Server Connector\n\n\nWebSocket is a protocol that provides full-duplex, persistent communication channels over a single TCP connection. Once a WebSocket connection is established, the connection stays open until the client or server decides to close this connection. This connection is also initialized by the client, in which case the WebSocket protocol uses an HTTP request to upgrade the connection from HTTP to WebSocket using two HTTP headers, \u201cConnection\u201d and \u201cUpgrade\u201d.\n\n\nFor example:\n\n\nGET ws://websocket.example.com/ HTTP/1.1\nOrigin: http://example.com\nConnection: Upgrade\nHost: websocket.example.com\nUpgrade: websocket\n\n\n\n\nThis tells the server that the client needs to establish a WebSocket connection. If the server supports WebSocket, it sends the response agreeing to establish the connection using the \u201cUpgrade\u201d header.\n\n\nFor example:\n\n\nHTTP/1.1 101 WebSocket Protocol Handshake\nDate: Wed, 16 Oct 2013 10:07:34 GMT\nConnection: Upgrade\nUpgrade: WebSocket\n\n\n\n\nOnce this message is sent, the handshake is completed, and the initial HTTP connection is replaced by the WebSocket connection using the same underlying TCP/IP connection. Ballerina uses the same HTTP base path + WebSocket Upgrade path to upgrade the existing connection to a WebSocket \nconnection. \n\n\nDefining a WebSocket service in Ballerina\n\n\nA WebSocket service is defined in the same service base path as a REST service, since this is an upgrade from the REST service.\n\n\nStep 1: Add WebSocketUpgradePath\n\n\nAdd a base path and WebSocketUpgradePath to the service.\n\n\nFor example:\n\n\n@http:BasePath(\u201c/test\u201d)\n@ws:WebSocketUpgradePath(\u201c/websocket\u201d)\nservice myService {\n}\n\n\n\n\nIf you want to connect to this WebSocket endpoint, use \nws://host:port/test/websocket\n. \n\n\nStep 2: Add annotations to the resource level\n\n\nThere are several supported annotations for this release of Ballerina. \n\n\n@ws:OnOpen\n\n\nThis annotated resource will be called when a new client is connecting to the WebSocket endpoint. If something has to be done when a new client is connecting to the endpoint, you can add that logic to the relevant resource.\n\n\n@ws:OnTextMessage\n\n\nWhen the server is receiving a text message from the client, this resource will be called.\n\n\n@ws:OnClose\n\n\nWhen the client connection is closed, this resource will be called. \n\n\nExample\n\n\nimport ballerina.lang.messages;\n\n@http:BasePath (\"/test\")\n@ws:WebSocketUpgradePath(\"/websocket\")\nservice helloWorld {\n    @ws:OnOpen\n    resource onOpenMessage(message m) {}\n\n    @ws:OnTextMessage\n    resource onTextMessage(message m) {}\n\n    @ws:OnClose\n    resource onCloseMessage(message m) {}\n}\n\n\n\n\nFunctions for WebSocket\n\n\nws:sendText(message, string)\n\n\nThis function is used if the user needs to send a text message to the same client who sent the WebSocket message.\n\n\n\n\n\n\n\n\nParameter Type\n\n\nDescription\n\n\nExpected Values\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nThe message received as the resource parameter\n\n\nThis should not be null. The message should contain all the details needed for sending the text, such as the recipient\n\n\n\n\n\n\nstring\n\n\nThe text message to send\n\n\nThis can be any string\n\n\n\n\n\n\n\n\nFor an example, see the simple echo server sample in \nsamples/websocket/echo-server/server/websocketEchoServer.bal\n.",
            "title": "WebSocket Server Connector"
        },
        {
            "location": "/server-connectors/websocket-server/#websocket-server-connector",
            "text": "WebSocket is a protocol that provides full-duplex, persistent communication channels over a single TCP connection. Once a WebSocket connection is established, the connection stays open until the client or server decides to close this connection. This connection is also initialized by the client, in which case the WebSocket protocol uses an HTTP request to upgrade the connection from HTTP to WebSocket using two HTTP headers, \u201cConnection\u201d and \u201cUpgrade\u201d.  For example:  GET ws://websocket.example.com/ HTTP/1.1\nOrigin: http://example.com\nConnection: Upgrade\nHost: websocket.example.com\nUpgrade: websocket  This tells the server that the client needs to establish a WebSocket connection. If the server supports WebSocket, it sends the response agreeing to establish the connection using the \u201cUpgrade\u201d header.  For example:  HTTP/1.1 101 WebSocket Protocol Handshake\nDate: Wed, 16 Oct 2013 10:07:34 GMT\nConnection: Upgrade\nUpgrade: WebSocket  Once this message is sent, the handshake is completed, and the initial HTTP connection is replaced by the WebSocket connection using the same underlying TCP/IP connection. Ballerina uses the same HTTP base path + WebSocket Upgrade path to upgrade the existing connection to a WebSocket \nconnection.",
            "title": "WebSocket Server Connector"
        },
        {
            "location": "/server-connectors/websocket-server/#defining-a-websocket-service-in-ballerina",
            "text": "A WebSocket service is defined in the same service base path as a REST service, since this is an upgrade from the REST service.",
            "title": "Defining a WebSocket service in Ballerina"
        },
        {
            "location": "/server-connectors/websocket-server/#step-1-add-websocketupgradepath",
            "text": "Add a base path and WebSocketUpgradePath to the service.  For example:  @http:BasePath(\u201c/test\u201d)\n@ws:WebSocketUpgradePath(\u201c/websocket\u201d)\nservice myService {\n}  If you want to connect to this WebSocket endpoint, use  ws://host:port/test/websocket .",
            "title": "Step 1: Add WebSocketUpgradePath"
        },
        {
            "location": "/server-connectors/websocket-server/#step-2-add-annotations-to-the-resource-level",
            "text": "There are several supported annotations for this release of Ballerina.",
            "title": "Step 2: Add annotations to the resource level"
        },
        {
            "location": "/server-connectors/websocket-server/#wsonopen",
            "text": "This annotated resource will be called when a new client is connecting to the WebSocket endpoint. If something has to be done when a new client is connecting to the endpoint, you can add that logic to the relevant resource.",
            "title": "@ws:OnOpen"
        },
        {
            "location": "/server-connectors/websocket-server/#wsontextmessage",
            "text": "When the server is receiving a text message from the client, this resource will be called.",
            "title": "@ws:OnTextMessage"
        },
        {
            "location": "/server-connectors/websocket-server/#wsonclose",
            "text": "When the client connection is closed, this resource will be called.",
            "title": "@ws:OnClose"
        },
        {
            "location": "/server-connectors/websocket-server/#example",
            "text": "import ballerina.lang.messages;\n\n@http:BasePath (\"/test\")\n@ws:WebSocketUpgradePath(\"/websocket\")\nservice helloWorld {\n    @ws:OnOpen\n    resource onOpenMessage(message m) {}\n\n    @ws:OnTextMessage\n    resource onTextMessage(message m) {}\n\n    @ws:OnClose\n    resource onCloseMessage(message m) {}\n}",
            "title": "Example"
        },
        {
            "location": "/server-connectors/websocket-server/#functions-for-websocket",
            "text": "",
            "title": "Functions for WebSocket"
        },
        {
            "location": "/server-connectors/websocket-server/#wssendtextmessage-string",
            "text": "This function is used if the user needs to send a text message to the same client who sent the WebSocket message.     Parameter Type  Description  Expected Values      message  The message received as the resource parameter  This should not be null. The message should contain all the details needed for sending the text, such as the recipient    string  The text message to send  This can be any string     For an example, see the simple echo server sample in  samples/websocket/echo-server/server/websocketEchoServer.bal .",
            "title": "ws:sendText(message, string)"
        },
        {
            "location": "/lang-ref/actions/",
            "text": "Actions\n\n\nAn action is an operation you can execute against a \nconnector\n. It represents a single interaction with a participant of the integration. A connector defines a set of actions. For example, the Twitter connector includes actions such as \ntweet\n, \nretweet\n, and \ndestroyStatus\n.\n\n\nIn the Composer, you invoke an action by navigating to the connector in the tool palette and dragging the icon of the action you want to the canvas.\n\n\nYou can define a new action by dragging the Action icon to the connector construct on the canvas:\n\n\n \n\n\nThe structure of an action definition is as follows:\n\n\n[ActionAnnotations]\n\naction ActionName (ConnectorName VariableName[, ([ActionParamAnnotations] TypeName VariableName)+]) (TypeName*)\n        [throws exception] {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}",
            "title": "Actions"
        },
        {
            "location": "/lang-ref/actions/#actions",
            "text": "An action is an operation you can execute against a  connector . It represents a single interaction with a participant of the integration. A connector defines a set of actions. For example, the Twitter connector includes actions such as  tweet ,  retweet , and  destroyStatus .  In the Composer, you invoke an action by navigating to the connector in the tool palette and dragging the icon of the action you want to the canvas.  You can define a new action by dragging the Action icon to the connector construct on the canvas:     The structure of an action definition is as follows:  [ActionAnnotations]\n\naction ActionName (ConnectorName VariableName[, ([ActionParamAnnotations] TypeName VariableName)+]) (TypeName*)\n        [throws exception] {\n    ConnectorDeclaration;*\n    VariableDeclaration;*\n    WorkerDeclaration;*\n    Statement;+\n}",
            "title": "Actions"
        },
        {
            "location": "/lang-ref/workers/",
            "text": "Workers\n\n\nA worker is a thread of execution. It is represented on a sequence diagram as a vertical \"lifeline\" of logic to be executed. \n\n\n\n\nWhen you create a \nresource\n, \nfunction\n, or \naction\n, a default worker is created automatically that performs the logic for that entity. You can add more workers to a resource or function, giving each worker its own logic to execute. This approach allows you to program parallel threads of execution. You can also use the \nfork/join\n statement to easily create a set of workers and have them process in parallel.\n\n\nWorkers do not share any state with each other. Upon invocation, the \u201cparent\u201d worker can pass a message to the new worker. Resource workers can also access the service's state.\n\n\nAdding a worker\n\n\nTo add a worker in Design View in the Composer, drag the Worker icon from the tool palette to your sequence diagram:\n\n\n\n\nTo add a worker when working directly with the source code of your program, a worker is defined and declared as follows:\n\n\nworker WorkerName (message m) {\n    Statement;+\n    [reply MessageName;]\n}\n\n\n\n\nYou then define the logic that you want the worker to reply. The worker can invoke any functions that are defined in the same package. \n\n\nIf the \nReply\n statement is present, it must be at the end of the worker definition. The reply indicates what message will be returned to the initiator if the initiator requires a response from the worker (see \"Receiving a reply from a worker\" below). If no Reply statement is present, it has the same effect as having sent a null message.\n\n\nInvoking the worker\n\n\nWorkers initially come into existence when the enclosing entity-- a \nresource\n, \nfunction\n, or \naction\n--becomes active. However, similar to a resource, the worker does not execute until it has been sent a message.\n\n\nA worker is triggered when a message is sent to the worker. You can configure the enclosing entity to send a message to the worker by dragging the Worker Invoke icon to the enclosing entity and typing the message name:\n\n\n\n\nOr type the following code in the Source View:\n\n\n<MessageName> -> <WorkerName>;\n\n\n\n\nFor example, if the message is named \nmsg\n and the worker is named \nsampleWorker\n, you would type:\n\n\nmsg -> sampleWorker;\n\n\n\n\nReceiving a reply from a worker\n\n\nThe worker can reply to the enclosing entity using a \nReply\n statement at the end of the worker defintion. You can configure the enclosing entity to receive the reply by dragging the Worker Receive icon to the point where you want the enclosing entity to receive the reply:\n\n\n\n\nOr type the following code in the Source View:\n\n\n<MessageName> <- <WorkerName>;\n\n\n\n\nFor example, to receive a reply from \nsampleWorker\n as a message named \nmsg\n:\n\n\nmsg <- sampleWorker;\n\n\n\n\nIf the worker does not reply, the enclosing entity will wait until the named worker completes and will return a null value for the message.\n\n\nIf there is no wait for completion of a particular worker, and if the enclosing entity finishes execution, all active workers are immediately killed prior to returning from the enclosing context. \n\n\nExamples\n\n\nThese examples show how to define, invoke, and receive a reply from a worker. \n\n\nInside the main() function\n\n\nimport ballerina.lang.system;\nimport ballerina.lang.message;\n// Global constants are visible to worker\nconst int index = 12;\n\nfunction main(string[] args) {\n  worker sampleWorker (message m)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(m, j);\n    system:println(\"constant value is \" + index);\n    reply m;\n  }\n\n  message result;\n  message msg = {};\n  msg -> sampleWorker;\n  system:println(\"After worker\");\n  result <- sampleWorker;\n  string s = message:getStringPayload(result);\n  system:println(s);\n\n}\n\n\n\n\nWhen you run the above Ballerina program, the following output is printed to the console:\n\n\nAfter worker\nconstant value is 12\n{\"name\":\"chanaka\"}\n\n\n\n\nInside a resource\n\n\nimport ballerina.lang.message;\nimport ballerina.lang.system;\n\n// Global constants are visible to worker\nconst int index = 12;\n\n@BasePath (\"/passthrough\")\nservice passthrough {\n\n    @POST\n    resource passthrough (message m) {\n      worker sampleWorker (message msg)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(msg, j);\n    system:println(\"constant value is \" + index);\n    reply msg;\n      }\n    message result;\n    m -> sampleWorker;\n    system:println(\"After worker\");\n    result <- sampleWorker;\n    string s = message:getStringPayload(result);\n    system:println(s);\n        reply result;\n    }\n}\n\n\n\n\nWhen the above service is running and is sent a message, it will return the following response from the worker back to the client:\n\n\n{\n  \"name\": \"chanaka\"\n}\n\n\n\n\nCalling a function from the worker\n\n\nThis example shows how a worker can call a function that's defined in the same package:\n\n\nimport ballerina.lang.system;\nimport ballerina.lang.message;\n// Global constants are visible to worker\nconst int index = 12;\n\nfunction main(string[] args) {\n  worker sampleWorker (message m)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(m, j);\n    system:println(\"constant value is \" + index);\n    printHello(\"I'm worker\");\n    reply m;\n  }\n\n  message result;\n  message msg = {};\n  msg -> sampleWorker;\n  system:println(\"After worker\");\n  printHello(\"I'm main function\");\n  result <- sampleWorker;\n  string s = message:getStringPayload(result);\n  system:println(s);\n\n}\n\nfunction printHello(string str) {\n  system:println(str);\n}\n\n\n\n\nWhen you run this program, the following output is printed to the console:\n\n\nAfter worker\nI'm main function\nconstant value is 12\nI'm worker\n{\"name\":\"chanaka\"}",
            "title": "Workers"
        },
        {
            "location": "/lang-ref/workers/#workers",
            "text": "A worker is a thread of execution. It is represented on a sequence diagram as a vertical \"lifeline\" of logic to be executed.    When you create a  resource ,  function , or  action , a default worker is created automatically that performs the logic for that entity. You can add more workers to a resource or function, giving each worker its own logic to execute. This approach allows you to program parallel threads of execution. You can also use the  fork/join  statement to easily create a set of workers and have them process in parallel.  Workers do not share any state with each other. Upon invocation, the \u201cparent\u201d worker can pass a message to the new worker. Resource workers can also access the service's state.",
            "title": "Workers"
        },
        {
            "location": "/lang-ref/workers/#adding-a-worker",
            "text": "To add a worker in Design View in the Composer, drag the Worker icon from the tool palette to your sequence diagram:   To add a worker when working directly with the source code of your program, a worker is defined and declared as follows:  worker WorkerName (message m) {\n    Statement;+\n    [reply MessageName;]\n}  You then define the logic that you want the worker to reply. The worker can invoke any functions that are defined in the same package.   If the  Reply  statement is present, it must be at the end of the worker definition. The reply indicates what message will be returned to the initiator if the initiator requires a response from the worker (see \"Receiving a reply from a worker\" below). If no Reply statement is present, it has the same effect as having sent a null message.",
            "title": "Adding a worker"
        },
        {
            "location": "/lang-ref/workers/#invoking-the-worker",
            "text": "Workers initially come into existence when the enclosing entity-- a  resource ,  function , or  action --becomes active. However, similar to a resource, the worker does not execute until it has been sent a message.  A worker is triggered when a message is sent to the worker. You can configure the enclosing entity to send a message to the worker by dragging the Worker Invoke icon to the enclosing entity and typing the message name:   Or type the following code in the Source View:  <MessageName> -> <WorkerName>;  For example, if the message is named  msg  and the worker is named  sampleWorker , you would type:  msg -> sampleWorker;",
            "title": "Invoking the worker"
        },
        {
            "location": "/lang-ref/workers/#receiving-a-reply-from-a-worker",
            "text": "The worker can reply to the enclosing entity using a  Reply  statement at the end of the worker defintion. You can configure the enclosing entity to receive the reply by dragging the Worker Receive icon to the point where you want the enclosing entity to receive the reply:   Or type the following code in the Source View:  <MessageName> <- <WorkerName>;  For example, to receive a reply from  sampleWorker  as a message named  msg :  msg <- sampleWorker;  If the worker does not reply, the enclosing entity will wait until the named worker completes and will return a null value for the message.  If there is no wait for completion of a particular worker, and if the enclosing entity finishes execution, all active workers are immediately killed prior to returning from the enclosing context.",
            "title": "Receiving a reply from a worker"
        },
        {
            "location": "/lang-ref/workers/#examples",
            "text": "These examples show how to define, invoke, and receive a reply from a worker.",
            "title": "Examples"
        },
        {
            "location": "/lang-ref/workers/#inside-the-main-function",
            "text": "import ballerina.lang.system;\nimport ballerina.lang.message;\n// Global constants are visible to worker\nconst int index = 12;\n\nfunction main(string[] args) {\n  worker sampleWorker (message m)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(m, j);\n    system:println(\"constant value is \" + index);\n    reply m;\n  }\n\n  message result;\n  message msg = {};\n  msg -> sampleWorker;\n  system:println(\"After worker\");\n  result <- sampleWorker;\n  string s = message:getStringPayload(result);\n  system:println(s);\n\n}  When you run the above Ballerina program, the following output is printed to the console:  After worker\nconstant value is 12\n{\"name\":\"chanaka\"}",
            "title": "Inside the main() function"
        },
        {
            "location": "/lang-ref/workers/#inside-a-resource",
            "text": "import ballerina.lang.message;\nimport ballerina.lang.system;\n\n// Global constants are visible to worker\nconst int index = 12;\n\n@BasePath (\"/passthrough\")\nservice passthrough {\n\n    @POST\n    resource passthrough (message m) {\n      worker sampleWorker (message msg)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(msg, j);\n    system:println(\"constant value is \" + index);\n    reply msg;\n      }\n    message result;\n    m -> sampleWorker;\n    system:println(\"After worker\");\n    result <- sampleWorker;\n    string s = message:getStringPayload(result);\n    system:println(s);\n        reply result;\n    }\n}  When the above service is running and is sent a message, it will return the following response from the worker back to the client:  {\n  \"name\": \"chanaka\"\n}",
            "title": "Inside a resource"
        },
        {
            "location": "/lang-ref/workers/#calling-a-function-from-the-worker",
            "text": "This example shows how a worker can call a function that's defined in the same package:  import ballerina.lang.system;\nimport ballerina.lang.message;\n// Global constants are visible to worker\nconst int index = 12;\n\nfunction main(string[] args) {\n  worker sampleWorker (message m)  {\n    json j;\n    j = `{\"name\":\"chanaka\"}`;\n    message:setJsonPayload(m, j);\n    system:println(\"constant value is \" + index);\n    printHello(\"I'm worker\");\n    reply m;\n  }\n\n  message result;\n  message msg = {};\n  msg -> sampleWorker;\n  system:println(\"After worker\");\n  printHello(\"I'm main function\");\n  result <- sampleWorker;\n  string s = message:getStringPayload(result);\n  system:println(s);\n\n}\n\nfunction printHello(string str) {\n  system:println(str);\n}  When you run this program, the following output is printed to the console:  After worker\nI'm main function\nconstant value is 12\nI'm worker\n{\"name\":\"chanaka\"}",
            "title": "Calling a function from the worker"
        },
        {
            "location": "/lang-ref/types-variables/",
            "text": "Types, Variables, and Constants\n\n\nThe Ballerina type system has value types and reference types. Ballerina comes with a set of built-in value types, a set of built-in reference types, array & struct type constructors to create new reference types, and an iterator type constructor to create new iterators.\n\n\nThe type system is illustrated in the following:\n\n\n\n\nDeclaring and initializing variables\n\n\nVariable declarations are considered \nstatements\n and can be added anywhere a statement is allowed. They can be interspersed with other statements in any order.\n\n\nA \nVariableDeclaration\n has the following structure:\n\n\nTypeName VariableName [ = Expression];\n\n\n\n\nVariables can be initialized using the standard literal value syntax for that type of variable or using expressions consisting of literal values and any other variables that are in-scope and already initialized. \n\n\nAllocating and deallocating variables\n\n\nAll value-typed variables are allocated on the stack, while all reference-typed variables are allocated on the heap. Value-typed variables are deallocated when they go out of scope, and all reference-typed variables are garbage-collected when they are no longer in use.\n\n\nAs all reference-typed variables are allocated on the heap, they must be explicitly allocated. This can be done by assigning them a literal value or by simply creating an empty value.\n\n\nThe \nany\n type\n\n\nThe \nany\n type is the root of the Ballerina data types. It represents a variable of any data type in the type system and provides a powerful way to deal with variables whose type is unknown during the compile time. Values of these variables can come from dynamic content, such as request and response messages, user input, etc. \n\n\nThe \nany\n type allows you to skip compile-time type checks, but use this wisely. You must always check the type and cast it to correct type when working with \nany\n type variables. \n\n\n\n\nNOTE: Currently, you can't check the type of a variable of type \nany\n. This will be implemented in a future release. \n\n\n\n\nFollowing are examples of using the \nany\n type:\n\n\nany a = getParameter();\nany b = \"foo\";\nany i = 5;\nany j = 10;\n\nint k = (int) i + (int) j;\n\n\n\n\nValue types\n\n\nBallerina includes the following value types:\n\n\n\n\nboolean\n\n\nint\n\n\nfloat\n\n\nstring\n\n\n\n\nThe types \nint\n and \nfloat\n both support 64-bit IEEE754 arithmetic. The \nboolean\n type has only two values: \ntrue\n and \nfalse\n. The \nstring\n type operates similar to value types in that assignment and comparison involve the full value and not the pointer.\n\n\nValue types can be initialized at declaration by assigning a value of that type. If they are not initialized, they have the following default values: \n\n\n\n\nint: 0\n\n\nfloat: 0.0\n\n\nstring: \"\" (empty string, not null)\n\n\nboolean: false\n\n\n\n\nUser-defined reference types\n\n\nStructured types (records)\n\n\nUser-defined record types are defined using the \nstruct\n keyword as follows:\n\n\nstruct TypeName {\n    TypeName FieldName;+\n}\n\n\n\n\nVariables of a struct type are defined by using the TypeName to declare the variable:\n\n\nTypeName VariableName;\n\n\n\n\nThe default value of a struct variable is null.\n\n\nVariables of struct types can be initialized at declaration time or later using the following syntax:\n\n\nVariableName = { FieldName : Expression, .. FieldName : Expression};\n\n\n\n\nThis results in a new instance of the struct being created with the named fields assigned the indicated values. If a field is not named, it has the default value for that type when the struct is created. Thus, structs with no values assigned can be created by assigning the value \n{}\n.\n\n\nArrays\n\n\nArrays are defined using the array constructor \n[]\n next to any type as follows:\n\n\nTypeName[] VariableName;\n\n\n\n\nThe default value of an array variable is null.\n\n\nAll arrays are unbounded in length and support 0-based indexing. Arrays may be sparse as well, and they will grow to meet whatever size is needed based on the index (subject to memory availability, of course).\n\n\nArray-typed variables can be initialized at declaration time or later using the following syntax:\n\n\nVariableName = [ Expression, Expression, ... ];\n\n\n\n\nIf there are no expressions given (i.e., the right-hand side is \n[]\n), the variable will be initialized to an array of length 0. Otherwise, it will be an array of the same length as the number of expressions, with each value being stored in the corresponding index of the array.\n\n\nAn array can have arrays as values. Here are some examples: \n\n\nint[][] a = [];\n\na[0] = [1, 2, 3, 5, 6];\na[1] = [10, 54];\na[2] = [4, 6, 1];\n\nint i = int[0][0] // Vaue of i is 1\ni = int[2][1]  // value of i is 6 now.\n\n\n\n\n\n\nNOTE: Currently, you can't initialize the whole array at once. For example, the following is not possible in the current release (we will improve this in a future release): \n\n\nint[][] a = [ [1, 2, 3, 5, 6], [10, 54], [4, 6, 1]];\n\n\n\n\nBuilt-in reference types\n\n\nBallerina comes with a pre-defined set of reference types that are key to supporting the types of programs that Ballerina developers are expected to write. These are supported by a set of standard library functions found in the packages \nballerina.lang.*\n. This section defines each of these types and defines their usage.\n\n\nType: \nmessage\n\n\nThe \nmessage\n type is an opaque type used to represent a request to a \nresource\n. This approach allows the \nresource\n to be network-protocol independent, even though a given \nresource\n is always tied to a particular protocol because a \nservice\n can only be bound to one network protocol at a time.\n\n\nLibrary functions for accessing information from this type are in the package \nballerina.lang.messages\n.\n\n\nA variable of type \nmessage\n can be initialized to hold an empty message as follows:\n\n\nmessage VarName = {};\n\n\n\n\nType: \nexception\n\n\nThe \nexception\n type, like \nmessage\n, is an opaque type used to hold an exception.\n\n\nSee \nException Handling\n for more information on exception handling and the \nexception\n type.\n\n\nType: \nmap\n\n\nThe \nmap\n type is a hash map with keys of type \nstring\n mapped to values of type \nany\n. Following are some examples:\n\n\nmap m = { \"a\" : 1, \"b\" : 2};\nint i = (int) m[\"a\"] + (int) m [\"b\"];\nany k = m[\"a\"];\n\n\n\n\nLibrary functions for accessing information from this type are in the package \nballerina.lang.maps\n.\n\n\nType: \nxml\n and \nxmldocument\n\n\nThe \nxml\n type is used to represent an XML element, and \nxmldocument\n is used to represent a full XML document. Ballerina also understands XML Schema and allows you to declare that an element or document must conform to a particular schema.\n\n\nXML element variables are declared in either of the following ways:\n\n\nxml VariableName;\nxml<{SchemaNamespaceName}SchemaTypeOrElementName> VariableName;\n\n\n\n\nThe first approach is a variable that can hold any XML element. The second approach is a variable whose value is an element that is of the indicated XML Schema type (if the name is that of an XML Schema Complex Type), or the element has the name and content model defined by the indicated XML Element declaration (if the name is that of an XML Schema Element declaration). Note that 'SchemaNamespaceName' may be empty, which means the type name is unqualified.\n\n\nSimilarly, the \nxmldocument\n type is used to represent a complete XML Document. Variables are declared as follows:\n\n\nxmldocument VariableName;\nxmldocument<{SchemaNamespaceName}DocumentElementTypeOrElementName> VariableName;\n\n\n\n\nThe first approach is a variable that may hold any XML document. The second approach is a variable whose value is an XML Document whose document element conforms to the indicated XML Schema type or XML Element declaration, similar to the element case above.\n\n\nLiteral XML values can be assigned to \nxml\n and \nxmldocument\n typed variables as follows:\n\n\nxml VariableName = `<xml-element-name [namespace declarations] [attributes]>element-content</xml-element-name>`;\n\n\n\n\nThe same syntax is used to assign a literal value to a variable of type \nxmldocument\n.\n\n\nWithin the literal XML expression (enclosed within back quote characters), other in-scope variables can be referred to using the syntax \n${VariableName}\n, which will be replaced by the value of the variable.\n\n\n\n\nNOTE: There is currently no way to insert the XML Declaration, processing instructions, DTD nodes, comment nodes, etc. to the document literally.\n\n\n\n\nLibrary functions for manipulating XML documents and elements are in the package \nballerina.lang.xmls\n.\n\n\nType: \njson\n\n\nA variable of type \njson\n can hold any JSON document. Ballerina also understands JSON Schema and allows you to declare that a JSON document must conform to a particular schema.\n\n\nJSON variables are declared in either of the following ways:\n\n\njson VariableName;\njson<SchemaName> VariableName;\n\n\n\n\nThe first approach is a variable that can hold any JSON document. The second approach is a variable whose value is a document that is of the indicated JSON Schema.\n\n\nLiteral JSON values can be assigned to \njson\n typed variables as follows:\n\n\njson VariableName = `{\"PropertyName\" : \"Value\", \"PropertyName\": \"Value\", ...}`;\n\n\n\n\nWithin the literal JSON expression (enclosed within back quote characters), other in-scope variables can be referred to using the syntax \n${VariableName}\n, which will be replaced by the value of the variable.\n\n\nLibrary functions for manipulating XML documents and elements are in the package \nballerina.lang.jsons\n.\n\n\n\n\nNOTE: We are considering a deeper marriage of JSON types and structs. This is because a JSON document with its properties can be viewed as being analogous to a struct with fields. Some of the deeper integration we are considering is the ability to use dot notation (similar to the syntax for accessing fields of a struct) to navigate through a JSON document, instead of the current approach of using a library function.\n\n\n\n\nType: \ndatatable\n\n\nThe \ndatatable\n type is used to hold tabular data, such as those returned from an SQL database queries, and provides cursor-based access to the data. In the current release, values of this type can only be created as the return value of certain actions of the SQL data connector (for details, see the \nballerina.data.sql\n package).\n\n\nNavigating a \ndatatable\n requires you to use the library functions in the package \nballerina.lang.datatables\n. More information is available in the documentation for that package.\n\n\nIterators\n\n\nIterators are defined using the iterator constructor \n~\n as follows:\n\n\nTypeName~\n\n\n\n\nThe \niterate\n statement navigates through iterator-typed values.\n\n\n\n\nNOTE: Iterators are still under development and not fully implemented.\n\n\n\n\nType conversion and mapping\n\n\nBallerina supports two styles of type conversion: implicit coercion and explicit casting. In addition, Ballerina allows you to add to the library of type convertors that may be explicitly invoked using the type cast operation.\n\n\nImplicit coercions\n\n\nThe following lossless type coercions are pre-defined in Ballerina:\n\n\n\n\nboolean -> int/float with values 0/0.0 or 1/1.0 for false or true, respectively\n\n\nint -> float\n\n\n\n\nExplicit casting\n\n\nIf a type conversion is lossy, it must be explicitly invoked via the type-casting operator. The syntax is as follows:\n\n\nTypeName1 VariableName1;\nTypeName2 VariableName2;\n\nVariableName2 = (TypeName2) VariableName1;\n\n\n\n\nThis cast will be rejected at compile time if a suitable type mapper is not found. Ballerina defines the following pre-defined type mappings:\n\n\n\n\nfloat -> int (by truncating at the decimal point)\n\n\nint -> boolean (by mapping 0 to false and any other value to true)\n\n\nfloat -> boolean (by mapping 0.0 to false and any other value to true)\n\n\n\n\nType Mapping\n\n\nBallerina allows you to program type converters that convert one type to another and then invoke them via the type cast operator.\n\n\nA \ntypemapper\n is defined as follows:\n\n\ntypemapper TypeMapperName (TypeName VariableName) (TypeName) {\n    Statement;+\n}\n\n\n\n\nThis declares that the type mapper named TypeMapperName is able to convert a value that is of the parameter type to a value of the result type. The logic of the conversion is found within the body of the type mapper as Ballerina code.\n\n\nIf a TypeMapper has been defined from Type1 to Type2, it will be invoked by the runtime using the cast operator as shown below:\n\n\nType1 t1;\nType2 t2;\n\nt2 = (Type2) t1;\n\n\n\n\nThat is, the registered type converter is invoked by indicating the type cast as above. Note that while the compiler can auto-detect the right converter to apply, Ballerina requires that the user request the appropriate converter by applying a cast, as the conversion may be lossy.\n\n\nBuilt-in type mappers\n\n\nIn addition to the built-in value type coercions, Ballerina also includes pre-defined type mappers to make it easier to program common scenarios. These are found in the specific packages for those types.",
            "title": "Types and Variables"
        },
        {
            "location": "/lang-ref/types-variables/#types-variables-and-constants",
            "text": "The Ballerina type system has value types and reference types. Ballerina comes with a set of built-in value types, a set of built-in reference types, array & struct type constructors to create new reference types, and an iterator type constructor to create new iterators.  The type system is illustrated in the following:",
            "title": "Types, Variables, and Constants"
        },
        {
            "location": "/lang-ref/types-variables/#declaring-and-initializing-variables",
            "text": "Variable declarations are considered  statements  and can be added anywhere a statement is allowed. They can be interspersed with other statements in any order.  A  VariableDeclaration  has the following structure:  TypeName VariableName [ = Expression];  Variables can be initialized using the standard literal value syntax for that type of variable or using expressions consisting of literal values and any other variables that are in-scope and already initialized.",
            "title": "Declaring and initializing variables"
        },
        {
            "location": "/lang-ref/types-variables/#allocating-and-deallocating-variables",
            "text": "All value-typed variables are allocated on the stack, while all reference-typed variables are allocated on the heap. Value-typed variables are deallocated when they go out of scope, and all reference-typed variables are garbage-collected when they are no longer in use.  As all reference-typed variables are allocated on the heap, they must be explicitly allocated. This can be done by assigning them a literal value or by simply creating an empty value.",
            "title": "Allocating and deallocating variables"
        },
        {
            "location": "/lang-ref/types-variables/#the-any-type",
            "text": "The  any  type is the root of the Ballerina data types. It represents a variable of any data type in the type system and provides a powerful way to deal with variables whose type is unknown during the compile time. Values of these variables can come from dynamic content, such as request and response messages, user input, etc.   The  any  type allows you to skip compile-time type checks, but use this wisely. You must always check the type and cast it to correct type when working with  any  type variables.    NOTE: Currently, you can't check the type of a variable of type  any . This will be implemented in a future release.    Following are examples of using the  any  type:  any a = getParameter();\nany b = \"foo\";\nany i = 5;\nany j = 10;\n\nint k = (int) i + (int) j;",
            "title": "The any type"
        },
        {
            "location": "/lang-ref/types-variables/#value-types",
            "text": "Ballerina includes the following value types:   boolean  int  float  string   The types  int  and  float  both support 64-bit IEEE754 arithmetic. The  boolean  type has only two values:  true  and  false . The  string  type operates similar to value types in that assignment and comparison involve the full value and not the pointer.  Value types can be initialized at declaration by assigning a value of that type. If they are not initialized, they have the following default values:    int: 0  float: 0.0  string: \"\" (empty string, not null)  boolean: false",
            "title": "Value types"
        },
        {
            "location": "/lang-ref/types-variables/#user-defined-reference-types",
            "text": "",
            "title": "User-defined reference types"
        },
        {
            "location": "/lang-ref/types-variables/#structured-types-records",
            "text": "User-defined record types are defined using the  struct  keyword as follows:  struct TypeName {\n    TypeName FieldName;+\n}  Variables of a struct type are defined by using the TypeName to declare the variable:  TypeName VariableName;  The default value of a struct variable is null.  Variables of struct types can be initialized at declaration time or later using the following syntax:  VariableName = { FieldName : Expression, .. FieldName : Expression};  This results in a new instance of the struct being created with the named fields assigned the indicated values. If a field is not named, it has the default value for that type when the struct is created. Thus, structs with no values assigned can be created by assigning the value  {} .",
            "title": "Structured types (records)"
        },
        {
            "location": "/lang-ref/types-variables/#arrays",
            "text": "Arrays are defined using the array constructor  []  next to any type as follows:  TypeName[] VariableName;  The default value of an array variable is null.  All arrays are unbounded in length and support 0-based indexing. Arrays may be sparse as well, and they will grow to meet whatever size is needed based on the index (subject to memory availability, of course).  Array-typed variables can be initialized at declaration time or later using the following syntax:  VariableName = [ Expression, Expression, ... ];  If there are no expressions given (i.e., the right-hand side is  [] ), the variable will be initialized to an array of length 0. Otherwise, it will be an array of the same length as the number of expressions, with each value being stored in the corresponding index of the array.  An array can have arrays as values. Here are some examples:   int[][] a = [];\n\na[0] = [1, 2, 3, 5, 6];\na[1] = [10, 54];\na[2] = [4, 6, 1];\n\nint i = int[0][0] // Vaue of i is 1\ni = int[2][1]  // value of i is 6 now.   NOTE: Currently, you can't initialize the whole array at once. For example, the following is not possible in the current release (we will improve this in a future release):   int[][] a = [ [1, 2, 3, 5, 6], [10, 54], [4, 6, 1]];",
            "title": "Arrays"
        },
        {
            "location": "/lang-ref/types-variables/#built-in-reference-types",
            "text": "Ballerina comes with a pre-defined set of reference types that are key to supporting the types of programs that Ballerina developers are expected to write. These are supported by a set of standard library functions found in the packages  ballerina.lang.* . This section defines each of these types and defines their usage.",
            "title": "Built-in reference types"
        },
        {
            "location": "/lang-ref/types-variables/#type-message",
            "text": "The  message  type is an opaque type used to represent a request to a  resource . This approach allows the  resource  to be network-protocol independent, even though a given  resource  is always tied to a particular protocol because a  service  can only be bound to one network protocol at a time.  Library functions for accessing information from this type are in the package  ballerina.lang.messages .  A variable of type  message  can be initialized to hold an empty message as follows:  message VarName = {};",
            "title": "Type: message"
        },
        {
            "location": "/lang-ref/types-variables/#type-exception",
            "text": "The  exception  type, like  message , is an opaque type used to hold an exception.  See  Exception Handling  for more information on exception handling and the  exception  type.",
            "title": "Type: exception"
        },
        {
            "location": "/lang-ref/types-variables/#type-map",
            "text": "The  map  type is a hash map with keys of type  string  mapped to values of type  any . Following are some examples:  map m = { \"a\" : 1, \"b\" : 2};\nint i = (int) m[\"a\"] + (int) m [\"b\"];\nany k = m[\"a\"];  Library functions for accessing information from this type are in the package  ballerina.lang.maps .",
            "title": "Type: map"
        },
        {
            "location": "/lang-ref/types-variables/#type-xml-and-xmldocument",
            "text": "The  xml  type is used to represent an XML element, and  xmldocument  is used to represent a full XML document. Ballerina also understands XML Schema and allows you to declare that an element or document must conform to a particular schema.  XML element variables are declared in either of the following ways:  xml VariableName;\nxml<{SchemaNamespaceName}SchemaTypeOrElementName> VariableName;  The first approach is a variable that can hold any XML element. The second approach is a variable whose value is an element that is of the indicated XML Schema type (if the name is that of an XML Schema Complex Type), or the element has the name and content model defined by the indicated XML Element declaration (if the name is that of an XML Schema Element declaration). Note that 'SchemaNamespaceName' may be empty, which means the type name is unqualified.  Similarly, the  xmldocument  type is used to represent a complete XML Document. Variables are declared as follows:  xmldocument VariableName;\nxmldocument<{SchemaNamespaceName}DocumentElementTypeOrElementName> VariableName;  The first approach is a variable that may hold any XML document. The second approach is a variable whose value is an XML Document whose document element conforms to the indicated XML Schema type or XML Element declaration, similar to the element case above.  Literal XML values can be assigned to  xml  and  xmldocument  typed variables as follows:  xml VariableName = `<xml-element-name [namespace declarations] [attributes]>element-content</xml-element-name>`;  The same syntax is used to assign a literal value to a variable of type  xmldocument .  Within the literal XML expression (enclosed within back quote characters), other in-scope variables can be referred to using the syntax  ${VariableName} , which will be replaced by the value of the variable.   NOTE: There is currently no way to insert the XML Declaration, processing instructions, DTD nodes, comment nodes, etc. to the document literally.   Library functions for manipulating XML documents and elements are in the package  ballerina.lang.xmls .",
            "title": "Type: xml and xmldocument"
        },
        {
            "location": "/lang-ref/types-variables/#type-json",
            "text": "A variable of type  json  can hold any JSON document. Ballerina also understands JSON Schema and allows you to declare that a JSON document must conform to a particular schema.  JSON variables are declared in either of the following ways:  json VariableName;\njson<SchemaName> VariableName;  The first approach is a variable that can hold any JSON document. The second approach is a variable whose value is a document that is of the indicated JSON Schema.  Literal JSON values can be assigned to  json  typed variables as follows:  json VariableName = `{\"PropertyName\" : \"Value\", \"PropertyName\": \"Value\", ...}`;  Within the literal JSON expression (enclosed within back quote characters), other in-scope variables can be referred to using the syntax  ${VariableName} , which will be replaced by the value of the variable.  Library functions for manipulating XML documents and elements are in the package  ballerina.lang.jsons .   NOTE: We are considering a deeper marriage of JSON types and structs. This is because a JSON document with its properties can be viewed as being analogous to a struct with fields. Some of the deeper integration we are considering is the ability to use dot notation (similar to the syntax for accessing fields of a struct) to navigate through a JSON document, instead of the current approach of using a library function.",
            "title": "Type: json"
        },
        {
            "location": "/lang-ref/types-variables/#type-datatable",
            "text": "The  datatable  type is used to hold tabular data, such as those returned from an SQL database queries, and provides cursor-based access to the data. In the current release, values of this type can only be created as the return value of certain actions of the SQL data connector (for details, see the  ballerina.data.sql  package).  Navigating a  datatable  requires you to use the library functions in the package  ballerina.lang.datatables . More information is available in the documentation for that package.",
            "title": "Type: datatable"
        },
        {
            "location": "/lang-ref/types-variables/#iterators",
            "text": "Iterators are defined using the iterator constructor  ~  as follows:  TypeName~  The  iterate  statement navigates through iterator-typed values.   NOTE: Iterators are still under development and not fully implemented.",
            "title": "Iterators"
        },
        {
            "location": "/lang-ref/types-variables/#type-conversion-and-mapping",
            "text": "Ballerina supports two styles of type conversion: implicit coercion and explicit casting. In addition, Ballerina allows you to add to the library of type convertors that may be explicitly invoked using the type cast operation.",
            "title": "Type conversion and mapping"
        },
        {
            "location": "/lang-ref/types-variables/#implicit-coercions",
            "text": "The following lossless type coercions are pre-defined in Ballerina:   boolean -> int/float with values 0/0.0 or 1/1.0 for false or true, respectively  int -> float",
            "title": "Implicit coercions"
        },
        {
            "location": "/lang-ref/types-variables/#explicit-casting",
            "text": "If a type conversion is lossy, it must be explicitly invoked via the type-casting operator. The syntax is as follows:  TypeName1 VariableName1;\nTypeName2 VariableName2;\n\nVariableName2 = (TypeName2) VariableName1;  This cast will be rejected at compile time if a suitable type mapper is not found. Ballerina defines the following pre-defined type mappings:   float -> int (by truncating at the decimal point)  int -> boolean (by mapping 0 to false and any other value to true)  float -> boolean (by mapping 0.0 to false and any other value to true)",
            "title": "Explicit casting"
        },
        {
            "location": "/lang-ref/types-variables/#type-mapping",
            "text": "Ballerina allows you to program type converters that convert one type to another and then invoke them via the type cast operator.  A  typemapper  is defined as follows:  typemapper TypeMapperName (TypeName VariableName) (TypeName) {\n    Statement;+\n}  This declares that the type mapper named TypeMapperName is able to convert a value that is of the parameter type to a value of the result type. The logic of the conversion is found within the body of the type mapper as Ballerina code.  If a TypeMapper has been defined from Type1 to Type2, it will be invoked by the runtime using the cast operator as shown below:  Type1 t1;\nType2 t2;\n\nt2 = (Type2) t1;  That is, the registered type converter is invoked by indicating the type cast as above. Note that while the compiler can auto-detect the right converter to apply, Ballerina requires that the user request the appropriate converter by applying a cast, as the conversion may be lossy.",
            "title": "Type Mapping"
        },
        {
            "location": "/lang-ref/types-variables/#built-in-type-mappers",
            "text": "In addition to the built-in value type coercions, Ballerina also includes pre-defined type mappers to make it easier to program common scenarios. These are found in the specific packages for those types.",
            "title": "Built-in type mappers"
        },
        {
            "location": "/lang-ref/statements/",
            "text": "Statements\n\n\nA statement can be one of the following:\n\n\n\n\nassignment\n\n\nif\n\n\nwhile\n\n\nbreak\n\n\nfork/join\n\n\ntry/catch and throw: see \nException Handling\n\n\nreturn\n\n\nreply\n\n\nworker initiation/invocation/join: see \nWorkers\n\n\naction invocation: see \nActions\n\n\ncomment\n\n\n\n\nThe rest of this page describes the statements you can use in your Ballerina program. \n\n\nAssignment\n\n\nAn assignment statement allows you to assign a value to a variable accessor. In the Composer, you can drag the Assignment icon \n from the tool palette to the canvas to add the statement to your program. \n\n\nAn assignment statement is defined as follows:\n\n\nVariableAccessor = Expression;\n\n\n\n\nwhere a \nVariableAccessor\n is one of:\n- VariableName\n- VariableAccessor'['ArrayIndex']'\n- VariableAccessor'['MapIndex']'\n- VariableAccessor.FieldName\n\n\nIf-else\n\n\nAn \nif-else\n statement provides a way to perform conditional execution. In the Composer, you can drag the If-Else icon \n from the tool palette to the canvas to add the statement to your program. \n\n\nAn \nif-else\n statement is defined as follows: \n\n\nif (BooleanExpression) {\n    Statement;*\n}\n[else if (BooleanExpression) {\n    Statement;*\n}]* [else {\n    Statement;*\n}]\n\n\n\n\nWhile\n\n\nA \nwhile\n statement provides a way to execute a series of statements as long as a Boolean expression is met. In the Composer, you can drag the While icon \n from the tool palette to the canvas to add the statement to your program. \n\n\nA \nwhile\n statement is defined as follows:\n\n\nwhile (BooleanExpression) {\n    Statement;+\n}\n\n\n\n\nBreak\n\n\nA \nbreak\n statement allows you to terminate the immediately enclosing loop. This is only allowed within the \nwhile\n construct. In the Composer, you can drag the Break icon \n from the tool palette to the canvas. \n\n\nA \nbreak\n statement is defined as follows:\n\n\nbreak;\n\n\n\n\nFork/Join\n\n\nA \nfork\n statement allows you to replicate a message to any number of parallel workers and have them independently operate on the copies of the message. The \njoin\n part of the \nfork\n statement allows you to define how the caller of \nfork\n will wait for the parallel workers to complete. \n\n\nfork (MessageName) {\n  worker WorkerName (message VariableName) {\n    VariableDeclaration;*\n    Statement;+\n    [reply MessageName;]\n  }+       \n} [join (JoinCondition) (message[] VariableName) {\n  Statement;*\n} timeout (Expression) (message[] VariableName) {\n  Statement;*  \n}]\n\n\n\n\nNote that if the \njoin\n clause is missing, it is equivalent to waiting for all workers to complete and ignorning the results.\n\n\nThe \nJoinCondition\n is one of the following:\n- \nany IntegerValue [(WorkerNameList)]\n: wait for any k (i.e., the IntegerValue) of the given workers or any of the workers\n- \nall [(WorkerNameList)]\n: wait for all given workers or all of the workers\n\n\nwhere \nWorkerNameList\n is a list of comma-separated names of workers.\n\n\n\n\nNote:\n The join condition \"any k\" where k != 1 is not yet implemented.\n\n\n\n\nWhen the \nJoinCondition\n has been satisfied, the corresponding slots of the message array will be filled with the returned messages from the workers in the workers' lexical order. If the condition asks for up to some number of results to be available to satisfy the condition, it may be the case that more than that number are available by the time the statements within the join condition are executed. If a particular worker has completed but not sent a response message, or not yet completed, the corresponding message slot will be null.\n\n\nThe \ntimeout\n clause allows one to specify a maximum time (in seconds) within which the join condition must be satisfied.\n\n\nReturn\n\n\nThe Return statement evaluates the expression, stops the current function, and returns the result of the expression to the caller. In the Composer, you can drag the Return icon \n from the tool palette to the canvas to add the statement to your program. \n\n\nA \nreturn\n statement is defined as follows:\n\n\nreturn Expression*;\n\n\n\n\nReply\n\n\nThe Reply statement sends the request message back to the client. In the Composer, you can drag the Reply icon \n from the tool palette to the canvas to add the statement to your program. \n\n\nA \nreply\n statement is defined as follows:\n\n\nreply Message?;\n\n\n\n\nNote that when you use Reply, the request message with its original HTTP headers is sent back to the client. These headers typically have information that is useful in the client -> server direction but not in the server -> client direction. If you want to strip those headers before sending the message back to the client, you can use the \nconvertToResponse\n function from the \nballerina.net.http\n package.\n\n\nComment\n\n\nComments are quite different in Ballerina in comparison to other languages. Comments are only allowed as a statement, i.e., only inside a resource, action, or function.\n\n\nBallerina has designed structured mechanisms via annotations to document all outer-level Ballerina constructs (services, resources, etc.), and comments only play the role of providing a comment about the logic of a resource, action, or function.\n\n\nAny statement that starts with the characters \n//\n is a comment.",
            "title": "Statements"
        },
        {
            "location": "/lang-ref/statements/#statements",
            "text": "A statement can be one of the following:   assignment  if  while  break  fork/join  try/catch and throw: see  Exception Handling  return  reply  worker initiation/invocation/join: see  Workers  action invocation: see  Actions  comment   The rest of this page describes the statements you can use in your Ballerina program.",
            "title": "Statements"
        },
        {
            "location": "/lang-ref/statements/#assignment",
            "text": "An assignment statement allows you to assign a value to a variable accessor. In the Composer, you can drag the Assignment icon   from the tool palette to the canvas to add the statement to your program.   An assignment statement is defined as follows:  VariableAccessor = Expression;  where a  VariableAccessor  is one of:\n- VariableName\n- VariableAccessor'['ArrayIndex']'\n- VariableAccessor'['MapIndex']'\n- VariableAccessor.FieldName",
            "title": "Assignment"
        },
        {
            "location": "/lang-ref/statements/#if-else",
            "text": "An  if-else  statement provides a way to perform conditional execution. In the Composer, you can drag the If-Else icon   from the tool palette to the canvas to add the statement to your program.   An  if-else  statement is defined as follows:   if (BooleanExpression) {\n    Statement;*\n}\n[else if (BooleanExpression) {\n    Statement;*\n}]* [else {\n    Statement;*\n}]",
            "title": "If-else"
        },
        {
            "location": "/lang-ref/statements/#while",
            "text": "A  while  statement provides a way to execute a series of statements as long as a Boolean expression is met. In the Composer, you can drag the While icon   from the tool palette to the canvas to add the statement to your program.   A  while  statement is defined as follows:  while (BooleanExpression) {\n    Statement;+\n}",
            "title": "While"
        },
        {
            "location": "/lang-ref/statements/#break",
            "text": "A  break  statement allows you to terminate the immediately enclosing loop. This is only allowed within the  while  construct. In the Composer, you can drag the Break icon   from the tool palette to the canvas.   A  break  statement is defined as follows:  break;",
            "title": "Break"
        },
        {
            "location": "/lang-ref/statements/#forkjoin",
            "text": "A  fork  statement allows you to replicate a message to any number of parallel workers and have them independently operate on the copies of the message. The  join  part of the  fork  statement allows you to define how the caller of  fork  will wait for the parallel workers to complete.   fork (MessageName) {\n  worker WorkerName (message VariableName) {\n    VariableDeclaration;*\n    Statement;+\n    [reply MessageName;]\n  }+       \n} [join (JoinCondition) (message[] VariableName) {\n  Statement;*\n} timeout (Expression) (message[] VariableName) {\n  Statement;*  \n}]  Note that if the  join  clause is missing, it is equivalent to waiting for all workers to complete and ignorning the results.  The  JoinCondition  is one of the following:\n-  any IntegerValue [(WorkerNameList)] : wait for any k (i.e., the IntegerValue) of the given workers or any of the workers\n-  all [(WorkerNameList)] : wait for all given workers or all of the workers  where  WorkerNameList  is a list of comma-separated names of workers.   Note:  The join condition \"any k\" where k != 1 is not yet implemented.   When the  JoinCondition  has been satisfied, the corresponding slots of the message array will be filled with the returned messages from the workers in the workers' lexical order. If the condition asks for up to some number of results to be available to satisfy the condition, it may be the case that more than that number are available by the time the statements within the join condition are executed. If a particular worker has completed but not sent a response message, or not yet completed, the corresponding message slot will be null.  The  timeout  clause allows one to specify a maximum time (in seconds) within which the join condition must be satisfied.",
            "title": "Fork/Join"
        },
        {
            "location": "/lang-ref/statements/#return",
            "text": "The Return statement evaluates the expression, stops the current function, and returns the result of the expression to the caller. In the Composer, you can drag the Return icon   from the tool palette to the canvas to add the statement to your program.   A  return  statement is defined as follows:  return Expression*;",
            "title": "Return"
        },
        {
            "location": "/lang-ref/statements/#reply",
            "text": "The Reply statement sends the request message back to the client. In the Composer, you can drag the Reply icon   from the tool palette to the canvas to add the statement to your program.   A  reply  statement is defined as follows:  reply Message?;  Note that when you use Reply, the request message with its original HTTP headers is sent back to the client. These headers typically have information that is useful in the client -> server direction but not in the server -> client direction. If you want to strip those headers before sending the message back to the client, you can use the  convertToResponse  function from the  ballerina.net.http  package.",
            "title": "Reply"
        },
        {
            "location": "/lang-ref/statements/#comment",
            "text": "Comments are quite different in Ballerina in comparison to other languages. Comments are only allowed as a statement, i.e., only inside a resource, action, or function.  Ballerina has designed structured mechanisms via annotations to document all outer-level Ballerina constructs (services, resources, etc.), and comments only play the role of providing a comment about the logic of a resource, action, or function.  Any statement that starts with the characters  //  is a comment.",
            "title": "Comment"
        },
        {
            "location": "/lang-ref/exceptions/",
            "text": "Exception Handling\n\n\nBallerina supports throwing and catching exceptions using a simple exception-handling model. This is supported by the \nexception\n type and the constructs \ntry-catch\n and \nthrow\n.\n\n\nBehavior\n\n\nAn exception can be thrown by a native Ballerina function or any Ballerina construct using the \nthrow\n statement. When thrown, the runtime searches for the nearest enclosing block containing a \ntry-catch\n statement. If none is found in the current stack frame, execution of the function (or resource or action or type mapper) stops, the frame is popped, and the search continues until a \ntry-catch\n statement is found. If none is found at the outermost level of the worker, that worker thread dies in an abnormal state.\n\n\nIf the exception goes through the default worker of a \nmain\n function without being caught, the entire program will stop executing. If the exception goes through a \nresource\n without being caught, that particular invocation of the service and resource will fail, and the server connector will choose the appropriate behavior in that situation.\n\n\nThe \nexception\n type\n\n\nExceptions are instances of a built-in, opaque reference type named \nexception\n.\n\n\nA collection of library functions can be used to set and get properties of exceptions, including stack traces. Note that unlike other languages, Ballerina does not allow developers to define subtypes of the exception type, and custom exceptions must be thrown by using custom category strings. As such, exception category strings starting with \"Ballerina:\" are reserved for system use only.\n\n\nVariables of type \nexception\n are defined and initialized to a new exception as follows:\n\n\nexception VariableName = {};\n\n\n\n\nLibrary functions for accessing information from this type are in the package \nballerina.lang.exceptions\n. These functions can be used to set the category of the exception, the descriptive messsage, and any additional properties.\n\n\nThe \ntry-catch\n statement\n\n\nIn Design View in the Composer, you can add a \ntry-catch\n statement to your sequence diagram by dragging the following icon from the tool palette to the canvas:\n\n\n\n\nThe syntax of a \ntry-catch\n is as follows:\n\n\ntry {\n    Statement;+\n} catch (exception e) {\n    Statement;+\n}\n\n\n\n\nIf any exception occurs while execution, the first block of statements and then the exception will be handled by the block after the \ncatch\n.\n\n\nThe \nthrow\n statement\n\n\nYou can add a \nthrow\n statement to your diagram by dragging the folloiwng icon to the canvas:\n\n\n\n\nThe syntax of a \nthrow\n statement is as follows:\n\n\nthrow ExceptionVariableName;\n\n\n\n\nThe \nthrow\n statement is used to throw an exception from the current location. An execution stack trace pointing to the current location will be automatically inserted into the exception before the runtime starts the exception-handling process.",
            "title": "Exception Handling"
        },
        {
            "location": "/lang-ref/exceptions/#exception-handling",
            "text": "Ballerina supports throwing and catching exceptions using a simple exception-handling model. This is supported by the  exception  type and the constructs  try-catch  and  throw .",
            "title": "Exception Handling"
        },
        {
            "location": "/lang-ref/exceptions/#behavior",
            "text": "An exception can be thrown by a native Ballerina function or any Ballerina construct using the  throw  statement. When thrown, the runtime searches for the nearest enclosing block containing a  try-catch  statement. If none is found in the current stack frame, execution of the function (or resource or action or type mapper) stops, the frame is popped, and the search continues until a  try-catch  statement is found. If none is found at the outermost level of the worker, that worker thread dies in an abnormal state.  If the exception goes through the default worker of a  main  function without being caught, the entire program will stop executing. If the exception goes through a  resource  without being caught, that particular invocation of the service and resource will fail, and the server connector will choose the appropriate behavior in that situation.",
            "title": "Behavior"
        },
        {
            "location": "/lang-ref/exceptions/#the-exception-type",
            "text": "Exceptions are instances of a built-in, opaque reference type named  exception .  A collection of library functions can be used to set and get properties of exceptions, including stack traces. Note that unlike other languages, Ballerina does not allow developers to define subtypes of the exception type, and custom exceptions must be thrown by using custom category strings. As such, exception category strings starting with \"Ballerina:\" are reserved for system use only.  Variables of type  exception  are defined and initialized to a new exception as follows:  exception VariableName = {};  Library functions for accessing information from this type are in the package  ballerina.lang.exceptions . These functions can be used to set the category of the exception, the descriptive messsage, and any additional properties.",
            "title": "The exception type"
        },
        {
            "location": "/lang-ref/exceptions/#the-try-catch-statement",
            "text": "In Design View in the Composer, you can add a  try-catch  statement to your sequence diagram by dragging the following icon from the tool palette to the canvas:   The syntax of a  try-catch  is as follows:  try {\n    Statement;+\n} catch (exception e) {\n    Statement;+\n}  If any exception occurs while execution, the first block of statements and then the exception will be handled by the block after the  catch .",
            "title": "The try-catch statement"
        },
        {
            "location": "/lang-ref/exceptions/#the-throw-statement",
            "text": "You can add a  throw  statement to your diagram by dragging the folloiwng icon to the canvas:   The syntax of a  throw  statement is as follows:  throw ExceptionVariableName;  The  throw  statement is used to throw an exception from the current location. An execution stack trace pointing to the current location will be automatically inserted into the exception before the runtime starts the exception-handling process.",
            "title": "The throw statement"
        },
        {
            "location": "/native-functions/",
            "text": "Native Functions\n\n\nBallerina provides many native functions that you can use in your Ballerina programs. For complete information, see the \nBallerina API documentation\n.",
            "title": "API Documentation"
        },
        {
            "location": "/native-functions/#native-functions",
            "text": "Ballerina provides many native functions that you can use in your Ballerina programs. For complete information, see the  Ballerina API documentation .",
            "title": "Native Functions"
        },
        {
            "location": "/spec/",
            "text": "Language Specification\n\n\nIf you want to learn more about the inner workings of the Ballerina language itself, you can read the \nlanguage specification\n in the Ballerina repository on GitHub.",
            "title": "Language Specification"
        },
        {
            "location": "/spec/#language-specification",
            "text": "If you want to learn more about the inner workings of the Ballerina language itself, you can read the  language specification  in the Ballerina repository on GitHub.",
            "title": "Language Specification"
        },
        {
            "location": "/architecture/",
            "text": "Ballerina Architecture\n\n\nBallerina is an open-source, community project that was created by WSO2, Inc. To help you understand how it was designed, the current architecture, and plans for the future, you can view the \ndesign and architecture documents\n, which are freely available as Google docs.",
            "title": "Architecture Design Documents"
        },
        {
            "location": "/architecture/#ballerina-architecture",
            "text": "Ballerina is an open-source, community project that was created by WSO2, Inc. To help you understand how it was designed, the current architecture, and plans for the future, you can view the  design and architecture documents , which are freely available as Google docs.",
            "title": "Ballerina Architecture"
        }
    ]
}